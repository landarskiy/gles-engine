/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Tue Mar 11 04:18:25 CET 2014 ----! */

package jogamp.opengl.es3;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import javax.media.opengl.GLBase;
import javax.media.opengl.GL;
import javax.media.opengl.GL2ES2;
import javax.media.opengl.GL2ES3;
import javax.media.opengl.GL3ES3;
import javax.media.opengl.GL4ES3;
import javax.media.opengl.GLES3;
import javax.media.opengl.GLArrayData;
import javax.media.opengl.GLUniformData;
import com.jogamp.common.nio.Buffers;
import com.jogamp.opengl.util.GLBuffers;
import java.io.PrintStream;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GLES3Impl implements GLBase, GL, GL2ES2, GLES2, GL2ES3, GL3ES3, GL4ES3, GLES3{
  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glActiveTexture(int texture)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glActiveTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glActiveTexture"));
    }
        dispatch_glActiveTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glActiveTexture}(GLenum texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glActiveTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glAlphaFuncQCOM}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_QCOM_alpha_test</code>   */
  public void glAlphaFuncQCOM(int func, float ref)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glAlphaFuncQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAlphaFuncQCOM"));
    }
        dispatch_glAlphaFuncQCOM1(func, ref, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAlphaFuncQCOM}(GLenum func, GLclampf ref); </code> <br>Part of <code>GL_QCOM_alpha_test</code>   */
  private native void dispatch_glAlphaFuncQCOM1(int func, float ref, long procAddress);

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glAttachShader(int program, int shader)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glAttachShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glAttachShader"));
    }
        dispatch_glAttachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glAttachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glAttachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glBeginPerfMonitorAMD(int monitor)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginPerfMonitorAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginPerfMonitorAMD"));
    }
        dispatch_glBeginPerfMonitorAMD1(monitor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  private native void dispatch_glBeginPerfMonitorAMD1(int monitor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginQuery}(GLenum target, GLuint id); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  public void glBeginQuery(int target, int id)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginQuery;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginQuery"));
    }
        dispatch_glBeginQuery1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginQuery}(GLenum target, GLuint id); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  private native void dispatch_glBeginQuery1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBeginTransformFeedback}(GLenum primitiveMode); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glBeginTransformFeedback(int primitiveMode)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBeginTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBeginTransformFeedback"));
    }
        dispatch_glBeginTransformFeedback1(primitiveMode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBeginTransformFeedback}(GLenum primitiveMode); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glBeginTransformFeedback1(int primitiveMode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glBindAttribLocation(int program, int index, String name)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindAttribLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindAttribLocation"));
    }
        dispatch_glBindAttribLocation1(program, index, name, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindAttribLocation}(GLuint program, GLuint index, const GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glBindAttribLocation1(int program, int index, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBindBuffer(int target, int buffer)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBuffer"));
    }
        dispatch_glBindBuffer1(target, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBuffer}(GLenum target, GLuint buffer); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glBindBuffer1(int target, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBufferBase}(GLenum target, GLuint index, GLuint buffer); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glBindBufferBase(int target, int index, int buffer)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindBufferBase;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBufferBase"));
    }
        dispatch_glBindBufferBase1(target, index, buffer, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBufferBase}(GLenum target, GLuint index, GLuint buffer); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glBindBufferBase1(int target, int index, int buffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindBufferRange}(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glBindBufferRange(int target, int index, int buffer, long offset, long size)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindBufferRange"));
    }
        dispatch_glBindBufferRange1(target, index, buffer, offset, size, __addr_);
    bufferStateTracker.setBoundBufferObject(target, buffer);
  }

  /** Entry point to C language function: <code> void {@native glBindBufferRange}(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glBindBufferRange1(int target, int index, int buffer, long offset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glBindFramebuffer(int target, int framebuffer)  {

    if( 0 == framebuffer ) {
    if( GL_FRAMEBUFFER == target || 0x8CA9 /* GL_DRAW_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultDrawFramebuffer();
    } else if( 0x8CA8 /* GL_READ_FRAMEBUFFER */ == target ) {
    framebuffer = _context.getDefaultReadFramebuffer();
    }
    }
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindFramebuffer"));
    }
        dispatch_glBindFramebuffer1(target, framebuffer, __addr_);
    _context.setBoundFramebuffer(target, framebuffer);
  }

  /** Entry point to C language function: <code> void {@native glBindFramebuffer}(GLenum target, GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  private native void dispatch_glBindFramebuffer1(int target, int framebuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glBindRenderbuffer(int target, int renderbuffer)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindRenderbuffer"));
    }
        dispatch_glBindRenderbuffer1(target, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindRenderbuffer}(GLenum target, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  private native void dispatch_glBindRenderbuffer1(int target, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindSampler}(GLuint unit, GLuint sampler); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public void glBindSampler(int unit, int sampler)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindSampler;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindSampler"));
    }
        dispatch_glBindSampler1(unit, sampler, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindSampler}(GLuint unit, GLuint sampler); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  private native void dispatch_glBindSampler1(int unit, int sampler, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBindTexture(int target, int texture)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTexture"));
    }
        dispatch_glBindTexture1(target, texture, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTexture}(GLenum target, GLuint texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glBindTexture1(int target, int texture, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindTransformFeedback}(GLenum target, GLuint id); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  public void glBindTransformFeedback(int target, int id)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindTransformFeedback"));
    }
        dispatch_glBindTransformFeedback1(target, id, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindTransformFeedback}(GLenum target, GLuint id); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  private native void dispatch_glBindTransformFeedback1(int target, int id, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexArray}(GLuint array); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>   */
  public void glBindVertexArray(int array)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindVertexArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexArray"));
    }
        dispatch_glBindVertexArray1(array, __addr_);
    bufferStateTracker.setBoundBufferObject(GL2GL3.GL_VERTEX_ARRAY_BINDING, array);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArray}(GLuint array); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glBindVertexArray1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public void glBindVertexArrayOES(int array)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBindVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBindVertexArrayOES"));
    }
        dispatch_glBindVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBindVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  private native void dispatch_glBindVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBlendColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendColor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendColor"));
    }
        dispatch_glBlendColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glBlendColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_blend_subtract</code>   */
  public void glBlendEquation(int mode)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquation"));
    }
        dispatch_glBlendEquation1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquation}(GLenum mode); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_blend_subtract</code>   */
  private native void dispatch_glBlendEquation1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>; <code>GL_OES_blend_equation_separate</code>   */
  public void glBlendEquationSeparate(int modeRGB, int modeAlpha)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendEquationSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendEquationSeparate"));
    }
        dispatch_glBlendEquationSeparate1(modeRGB, modeAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendEquationSeparate}(GLenum modeRGB, GLenum modeAlpha); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>; <code>GL_OES_blend_equation_separate</code>   */
  private native void dispatch_glBlendEquationSeparate1(int modeRGB, int modeAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glBlendFunc(int sfactor, int dfactor)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFunc"));
    }
        dispatch_glBlendFunc1(sfactor, dfactor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFunc}(GLenum sfactor, GLenum dfactor); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glBlendFunc1(int sfactor, int dfactor, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_blend_func_separate</code>   */
  public void glBlendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlendFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlendFuncSeparate"));
    }
        dispatch_glBlendFuncSeparate1(srcRGB, dstRGB, srcAlpha, dstAlpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlendFuncSeparate}(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha); </code> <br>Part of <code>GL_VERSION_1_4</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_blend_func_separate</code>   */
  private native void dispatch_glBlendFuncSeparate1(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlitFramebuffer}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_framebuffer_blit</code>   */
  public void glBlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlitFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlitFramebuffer"));
    }
        dispatch_glBlitFramebuffer1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebuffer}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_framebuffer_blit</code>   */
  private native void dispatch_glBlitFramebuffer1(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlitFramebufferANGLE}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_ANGLE_framebuffer_blit</code>   */
  public void glBlitFramebufferANGLE(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlitFramebufferANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlitFramebufferANGLE"));
    }
        dispatch_glBlitFramebufferANGLE1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebufferANGLE}(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_ANGLE_framebuffer_blit</code>   */
  private native void dispatch_glBlitFramebufferANGLE1(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> void {@native glBlitFramebufferNV}(int srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_NV_framebuffer_blit</code>   */
  public void glBlitFramebufferNV(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBlitFramebufferNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBlitFramebufferNV"));
    }
        dispatch_glBlitFramebufferNV1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBlitFramebufferNV}(int srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>GL_NV_framebuffer_blit</code>   */
  private native void dispatch_glBlitFramebufferNV1(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glBufferSubData(int target, long offset, long size, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glBufferSubData"));
    }
        dispatch_glBufferSubData1(target, offset, size, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glBufferSubData}(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glBufferSubData1(int target, long offset, long size, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public int glCheckFramebufferStatus(int target)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCheckFramebufferStatus;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCheckFramebufferStatus"));
    }
        return dispatch_glCheckFramebufferStatus1(target, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glCheckFramebufferStatus}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  private native int dispatch_glCheckFramebufferStatus1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glClear(int mask)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClear;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClear"));
    }
        dispatch_glClear1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClear}(GLbitfield mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glClear1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferfi}(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glClearBufferfi(int buffer, int drawbuffer, float depth, int stencil)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferfi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfi"));
    }
        dispatch_glClearBufferfi1(buffer, drawbuffer, depth, stencil, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfi}(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glClearBufferfi1(int buffer, int drawbuffer, float depth, int stencil, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glClearBufferfv(int buffer, int drawbuffer, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfv"));
    }
        dispatch_glClearBufferfv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glClearBufferfv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferfv}(GLenum buffer, GLint drawbuffer, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glClearBufferfv(int buffer, int drawbuffer, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferfv"));
    }
        dispatch_glClearBufferfv1(buffer, drawbuffer, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearBufferiv(int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferiv"));
    }
        dispatch_glClearBufferiv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearBufferiv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferiv}(GLenum buffer, GLint drawbuffer, const GLint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glClearBufferiv(int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferiv"));
    }
        dispatch_glClearBufferiv1(buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glClearBufferuiv(int buffer, int drawbuffer, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferuiv"));
    }
        dispatch_glClearBufferuiv1(buffer, drawbuffer, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glClearBufferuiv1(int buffer, int drawbuffer, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearBufferuiv}(GLenum buffer, GLint drawbuffer, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glClearBufferuiv(int buffer, int drawbuffer, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearBufferuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearBufferuiv"));
    }
        dispatch_glClearBufferuiv1(buffer, drawbuffer, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glClearColor(float red, float green, float blue, float alpha)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearColor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearColor"));
    }
        dispatch_glClearColor1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearColor}(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  private native void dispatch_glClearColor1(float red, float green, float blue, float alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLfloat depth); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>; <code>GL_OES_single_precision</code>   */
  public void glClearDepthf(float depth)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearDepthf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearDepthf"));
    }
        dispatch_glClearDepthf1(depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearDepthf}(GLfloat depth); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>; <code>GL_OES_single_precision</code>   */
  private native void dispatch_glClearDepthf1(float depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glClearStencil(int s)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClearStencil;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClearStencil"));
    }
        dispatch_glClearStencil1(s, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glClearStencil}(GLint s); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glClearStencil1(int s, long procAddress);

  /** Entry point to C language function: <code> GLenum {@native glClientWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  public int glClientWaitSync(long sync, int flags, long timeout)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glClientWaitSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glClientWaitSync"));
    }
        return dispatch_glClientWaitSync1(sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glClientWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  private native int dispatch_glClientWaitSync1(long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glColorMask(boolean red, boolean green, boolean blue, boolean alpha)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glColorMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glColorMask"));
    }
        dispatch_glColorMask1(red, green, blue, alpha, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glColorMask}(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glColorMask1(boolean red, boolean green, boolean blue, boolean alpha, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glCompileShader(int shader)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompileShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompileShader"));
    }
        dispatch_glCompileShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompileShader}(GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glCompileShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage2D"));
    }
        dispatch_glCompressedTexImage2D1(target, level, internalformat, width, height, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glCompressedTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage3D"));
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>   */
  public void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexImage3D"));
    }
        dispatch_glCompressedTexImage3D1(target, level, internalformat, width, height, depth, border, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexImage3D}(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glCompressedTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage2D"));
    }
        dispatch_glCompressedTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glCompressedTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Buffer data)  {

    checkUnpackPBOUnbound(true);
    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage3D"));
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>   */
  public void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCompressedTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCompressedTexSubImage3D"));
    }
        dispatch_glCompressedTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCompressedTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_3</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glCompressedTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, long data_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyBufferSubData}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_copy_buffer</code>, <code>GL_VERSION_3_1</code>   */
  public void glCopyBufferSubData(int readTarget, int writeTarget, long readOffset, long writeOffset, long size)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyBufferSubData;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyBufferSubData"));
    }
        dispatch_glCopyBufferSubData1(readTarget, writeTarget, readOffset, writeOffset, size, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyBufferSubData}(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_copy_buffer</code>, <code>GL_VERSION_3_1</code>   */
  private native void dispatch_glCopyBufferSubData1(int readTarget, int writeTarget, long readOffset, long writeOffset, long size, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexImage2D"));
    }
        dispatch_glCopyTexImage2D1(target, level, internalformat, x, y, width, height, border, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexImage2D}(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glCopyTexImage2D1(int target, int level, int internalformat, int x, int y, int width, int height, int border, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage2D"));
    }
        dispatch_glCopyTexSubImage2D1(target, level, xoffset, yoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glCopyTexSubImage2D1(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>   */
  public void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTexSubImage3D"));
    }
        dispatch_glCopyTexSubImage3D1(target, level, xoffset, yoffset, zoffset, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glCopyTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glCopyTextureLevelsAPPLE}(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount); </code> <br>Part of <code>GL_APPLE_copy_texture_levels</code>   */
  public void glCopyTextureLevelsAPPLE(int destinationTexture, int sourceTexture, int sourceBaseLevel, int sourceLevelCount)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCopyTextureLevelsAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCopyTextureLevelsAPPLE"));
    }
        dispatch_glCopyTextureLevelsAPPLE1(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCopyTextureLevelsAPPLE}(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount); </code> <br>Part of <code>GL_APPLE_copy_texture_levels</code>   */
  private native void dispatch_glCopyTextureLevelsAPPLE1(int destinationTexture, int sourceTexture, int sourceBaseLevel, int sourceLevelCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageMaskNV}(GLboolean mask); </code> <br>Part of <code>GL_NV_coverage_sample</code>   */
  public void glCoverageMaskNV(boolean mask)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCoverageMaskNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageMaskNV"));
    }
        dispatch_glCoverageMaskNV1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageMaskNV}(GLboolean mask); </code> <br>Part of <code>GL_NV_coverage_sample</code>   */
  private native void dispatch_glCoverageMaskNV1(boolean mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glCoverageOperationNV}(GLenum operation); </code> <br>Part of <code>GL_NV_coverage_sample</code>   */
  public void glCoverageOperationNV(int operation)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCoverageOperationNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCoverageOperationNV"));
    }
        dispatch_glCoverageOperationNV1(operation, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCoverageOperationNV}(GLenum operation); </code> <br>Part of <code>GL_NV_coverage_sample</code>   */
  private native void dispatch_glCoverageOperationNV1(int operation, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public int glCreateProgram()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateProgram"));
    }
        return dispatch_glCreateProgram1(__addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateProgram}(void); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native int dispatch_glCreateProgram1(long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public int glCreateShader(int type)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCreateShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCreateShader"));
    }
        return dispatch_glCreateShader1(type, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glCreateShader}(GLenum type); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native int dispatch_glCreateShader1(int type, long procAddress);

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glCullFace(int mode)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glCullFace;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glCullFace"));
    }
        dispatch_glCullFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glCullFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glCullFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageControl}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_ARB_debug_output</code>; <code>GL_KHR_debug</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDebugMessageControl(int source, int type, int severity, int count, IntBuffer ids, boolean enabled)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDebugMessageControl;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageControl"));
    }
        dispatch_glDebugMessageControl1(source, type, severity, count, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageControl}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_ARB_debug_output</code>; <code>GL_KHR_debug</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDebugMessageControl1(int source, int type, int severity, int count, Object ids, int ids_byte_offset, boolean ids_is_direct, boolean enabled, long procAddress);

  /** Entry point to C language function: <code> void {@native glDebugMessageControl}(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *  ids, GLboolean enabled); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_ARB_debug_output</code>; <code>GL_KHR_debug</code>   */
  public void glDebugMessageControl(int source, int type, int severity, int count, int[] ids, int ids_offset, boolean enabled)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDebugMessageControl;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageControl"));
    }
        dispatch_glDebugMessageControl1(source, type, severity, count, ids, Buffers.SIZEOF_INT * ids_offset, false, enabled, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsert}(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *  buf); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_ARB_debug_output</code>; <code>GL_KHR_debug</code>   */
  public void glDebugMessageInsert(int source, int type, int id, int severity, int length, String buf)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDebugMessageInsert;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDebugMessageInsert"));
    }
        dispatch_glDebugMessageInsert1(source, type, id, severity, length, buf, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDebugMessageInsert}(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *  buf); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_ARB_debug_output</code>; <code>GL_KHR_debug</code>   */
  private native void dispatch_glDebugMessageInsert1(int source, int type, int id, int severity, int length, String buf, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteBuffers(int n, IntBuffer buffers)  {

    bufferObjectTracker.notifyBuffersDeleted(n, buffers);
    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
    }
        dispatch_glDeleteBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteBuffers}(GLsizei n, const GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDeleteBuffers(int n, int[] buffers, int buffers_offset)  {

    bufferObjectTracker.notifyBuffersDeleted(n, buffers, buffers_offset);
    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteBuffers"));
    }
        dispatch_glDeleteBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei, const GLuint * ); </code> <br>Part of <code>GL_NV_fence</code>
      @param arg1 a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFencesNV(int arg0, IntBuffer arg1)  {

    Buffers.rangeCheck(arg1, arg0);
    final boolean arg1_is_direct = Buffers.isDirect(arg1);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFencesNV"));
    }
        dispatch_glDeleteFencesNV1(arg0, arg1_is_direct ? arg1 : Buffers.getArray(arg1), arg1_is_direct ? Buffers.getDirectBufferByteOffset(arg1) : Buffers.getIndirectBufferByteOffset(arg1), arg1_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei, const GLuint * ); </code> <br>Part of <code>GL_NV_fence</code>
      @param arg1 a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFencesNV1(int arg0, Object arg1, int arg1_byte_offset, boolean arg1_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFencesNV}(GLsizei, const GLuint * ); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glDeleteFencesNV(int arg0, int[] arg1, int arg1_offset)  {

    Buffers.rangeCheck(arg1, arg1_offset, arg0);
    if(arg1 != null && arg1.length <= arg1_offset)
      throw new GLException("array offset argument \"arg1_offset\" (" + arg1_offset + ") equals or exceeds array length (" + arg1.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFencesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFencesNV"));
    }
        dispatch_glDeleteFencesNV1(arg0, arg1, Buffers.SIZEOF_INT * arg1_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteFramebuffers}(GLsizei n, const GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glDeleteFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteFramebuffers"));
    }
        dispatch_glDeleteFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeletePerfMonitorsAMD(int n, IntBuffer monitors)  {

    final boolean monitors_is_direct = Buffers.isDirect(monitors);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeletePerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeletePerfMonitorsAMD"));
    }
        dispatch_glDeletePerfMonitorsAMD1(n, monitors_is_direct ? monitors : Buffers.getArray(monitors), monitors_is_direct ? Buffers.getDirectBufferByteOffset(monitors) : Buffers.getIndirectBufferByteOffset(monitors), monitors_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeletePerfMonitorsAMD1(int n, Object monitors, int monitors_byte_offset, boolean monitors_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeletePerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glDeletePerfMonitorsAMD(int n, int[] monitors, int monitors_offset)  {

    if(monitors != null && monitors.length <= monitors_offset)
      throw new GLException("array offset argument \"monitors_offset\" (" + monitors_offset + ") equals or exceeds array length (" + monitors.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeletePerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeletePerfMonitorsAMD"));
    }
        dispatch_glDeletePerfMonitorsAMD1(n, monitors, Buffers.SIZEOF_INT * monitors_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glDeleteProgram(int program)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteProgram"));
    }
        dispatch_glDeleteProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glDeleteProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteQueries"));
    }
        dispatch_glDeleteQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteQueries}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  public void glDeleteQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteQueries"));
    }
        dispatch_glDeleteQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteRenderbuffers}(GLsizei n, const GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glDeleteRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteRenderbuffers"));
    }
        dispatch_glDeleteRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteSamplers(int count, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteSamplers"));
    }
        dispatch_glDeleteSamplers1(count, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteSamplers1(int count, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteSamplers}(GLsizei count, const GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public void glDeleteSamplers(int count, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteSamplers"));
    }
        dispatch_glDeleteSamplers1(count, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glDeleteShader(int shader)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteShader"));
    }
        dispatch_glDeleteShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteShader}(GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glDeleteShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteSync}(GLsync sync); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  public void glDeleteSync(long sync)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteSync"));
    }
        dispatch_glDeleteSync1(sync, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteSync}(GLsync sync); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  private native void dispatch_glDeleteSync1(long sync, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
    }
        dispatch_glDeleteTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTextures}(GLsizei n, const GLuint *  textures); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDeleteTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTextures"));
    }
        dispatch_glDeleteTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteTransformFeedbacks(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacks"));
    }
        dispatch_glDeleteTransformFeedbacks1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteTransformFeedbacks1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteTransformFeedbacks}(GLsizei n, const GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  public void glDeleteTransformFeedbacks(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteTransformFeedbacks"));
    }
        dispatch_glDeleteTransformFeedbacks1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteVertexArrays(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArrays"));
    }
        dispatch_glDeleteVertexArrays1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteVertexArrays1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArrays}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>   */
  public void glDeleteVertexArrays(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArrays"));
    }
        dispatch_glDeleteVertexArrays1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDeleteVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArraysOES"));
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDeleteVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDeleteVertexArraysOES}(GLsizei n, const GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public void glDeleteVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDeleteVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDeleteVertexArraysOES"));
    }
        dispatch_glDeleteVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDepthFunc(int func)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthFunc"));
    }
        dispatch_glDepthFunc1(func, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthFunc}(GLenum func); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glDepthFunc1(int func, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDepthMask(boolean flag)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthMask"));
    }
        dispatch_glDepthMask1(flag, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthMask}(GLboolean flag); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glDepthMask1(boolean flag, long procAddress);

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLfloat zNear, GLfloat zFar); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>; <code>GL_OES_single_precision</code>   */
  public void glDepthRangef(float zNear, float zFar)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDepthRangef;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDepthRangef"));
    }
        dispatch_glDepthRangef1(zNear, zFar, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDepthRangef}(GLfloat zNear, GLfloat zFar); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>; <code>GL_OES_single_precision</code>   */
  private native void dispatch_glDepthRangef1(float zNear, float zFar, long procAddress);

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glDetachShader(int program, int shader)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDetachShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDetachShader"));
    }
        dispatch_glDetachShader1(program, shader, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDetachShader}(GLuint program, GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glDetachShader1(int program, int shader, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDisable(int cap)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisable"));
    }
        dispatch_glDisable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glDisable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glDisableDriverControlQCOM(int driverControl)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableDriverControlQCOM"));
    }
        dispatch_glDisableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  private native void dispatch_glDisableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glDisableVertexAttribArray(int index)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDisableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDisableVertexAttribArray"));
    }
        dispatch_glDisableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDisableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glDisableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_EXT_discard_framebuffer</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, IntBuffer attachments)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDiscardFramebufferEXT"));
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_EXT_discard_framebuffer</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDiscardFramebufferEXT1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDiscardFramebufferEXT}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_EXT_discard_framebuffer</code>   */
  public void glDiscardFramebufferEXT(int target, int numAttachments, int[] attachments, int attachments_offset)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDiscardFramebufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDiscardFramebufferEXT"));
    }
        dispatch_glDiscardFramebufferEXT1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDrawArrays(int mode, int first, int count)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArrays"));
    }
        dispatch_glDrawArrays1(mode, first, count, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArrays}(GLenum mode, GLint first, GLsizei count); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glDrawArrays1(int mode, int first, int count, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstanced}(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>; <code>GL_ARB_draw_instanced</code>   */
  public void glDrawArraysInstanced(int mode, int first, int count, int instanceCount)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArraysInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstanced"));
    }
        dispatch_glDrawArraysInstanced1(mode, first, count, instanceCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstanced}(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>; <code>GL_ARB_draw_instanced</code>   */
  private native void dispatch_glDrawArraysInstanced1(int mode, int first, int count, int instanceCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedANGLE}(GLenum mode, GLint first, GLsizei count, GLsizei primcount); </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code>   */
  public void glDrawArraysInstancedANGLE(int mode, int first, int count, int primcount)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArraysInstancedANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstancedANGLE"));
    }
        dispatch_glDrawArraysInstancedANGLE1(mode, first, count, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedANGLE}(GLenum mode, GLint first, GLsizei count, GLsizei primcount); </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code>   */
  private native void dispatch_glDrawArraysInstancedANGLE1(int mode, int first, int count, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedNV}(GLenum mode, GLint first, GLsizei count, GLsizei primcount); </code> <br>Part of <code>GL_NV_draw_instanced</code>   */
  public void glDrawArraysInstancedNV(int mode, int first, int count, int primcount)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawArraysInstancedNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawArraysInstancedNV"));
    }
        dispatch_glDrawArraysInstancedNV1(mode, first, count, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawArraysInstancedNV}(GLenum mode, GLint first, GLsizei count, GLsizei primcount); </code> <br>Part of <code>GL_NV_draw_instanced</code>   */
  private native void dispatch_glDrawArraysInstancedNV1(int mode, int first, int count, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_0</code>; <code>GL_EXT_draw_buffers</code><code>GL_NV_draw_buffers</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawBuffers(int n, IntBuffer bufs)  {

    final boolean bufs_is_direct = Buffers.isDirect(bufs);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffers"));
    }
        dispatch_glDrawBuffers1(n, bufs_is_direct ? bufs : Buffers.getArray(bufs), bufs_is_direct ? Buffers.getDirectBufferByteOffset(bufs) : Buffers.getIndirectBufferByteOffset(bufs), bufs_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_0</code>; <code>GL_EXT_draw_buffers</code><code>GL_NV_draw_buffers</code>
      @param bufs a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawBuffers1(int n, Object bufs, int bufs_byte_offset, boolean bufs_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffers}(GLsizei n, const GLenum *  bufs); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_0</code>; <code>GL_EXT_draw_buffers</code><code>GL_NV_draw_buffers</code>   */
  public void glDrawBuffers(int n, int[] bufs, int bufs_offset)  {

    if(bufs != null && bufs.length <= bufs_offset)
      throw new GLException("array offset argument \"bufs_offset\" (" + bufs_offset + ") equals or exceeds array length (" + bufs.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffers"));
    }
        dispatch_glDrawBuffers1(n, bufs, Buffers.SIZEOF_INT * bufs_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffersIndexedEXT}(GLint n, const GLenum *  location, const GLint *  indices); </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code>
      @param location a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glDrawBuffersIndexedEXT(int n, IntBuffer location, IntBuffer indices)  {

    final boolean location_is_direct = Buffers.isDirect(location);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffersIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffersIndexedEXT"));
    }
        dispatch_glDrawBuffersIndexedEXT1(n, location_is_direct ? location : Buffers.getArray(location), location_is_direct ? Buffers.getDirectBufferByteOffset(location) : Buffers.getIndirectBufferByteOffset(location), location_is_direct, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawBuffersIndexedEXT}(GLint n, const GLenum *  location, const GLint *  indices); </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code>
      @param location a direct or array-backed {@link java.nio.IntBuffer}
      @param indices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glDrawBuffersIndexedEXT1(int n, Object location, int location_byte_offset, boolean location_is_direct, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawBuffersIndexedEXT}(GLint n, const GLenum *  location, const GLint *  indices); </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code>   */
  public void glDrawBuffersIndexedEXT(int n, int[] location, int location_offset, int[] indices, int indices_offset)  {

    if(location != null && location.length <= location_offset)
      throw new GLException("array offset argument \"location_offset\" (" + location_offset + ") equals or exceeds array length (" + location.length + ")");
    if(indices != null && indices.length <= indices_offset)
      throw new GLException("array offset argument \"indices_offset\" (" + indices_offset + ") equals or exceeds array length (" + indices.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawBuffersIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawBuffersIndexedEXT"));
    }
        dispatch_glDrawBuffersIndexedEXT1(n, location, Buffers.SIZEOF_INT * location_offset, false, indices, Buffers.SIZEOF_INT * indices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElements(int mode, int count, int type, Buffer indices)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
    }
        dispatch_glDrawElements1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glDrawElements(int mode, int count, int type, long indices_buffer_offset)  {

    checkElementVBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElements"));
    }
        dispatch_glDrawElements1(mode, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElements}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glDrawElements1(int mode, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei instanceCount); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>; <code>GL_ARB_draw_instanced</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstanced(int mode, int count, int type, Buffer indices, int instanceCount)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstanced"));
    }
        dispatch_glDrawElementsInstanced1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, instanceCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei instanceCount); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>; <code>GL_ARB_draw_instanced</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstanced1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int instanceCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei instanceCount); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>; <code>GL_ARB_draw_instanced</code>   */
  public void glDrawElementsInstanced(int mode, int count, int type, long indices_buffer_offset, int instanceCount)  {

    checkElementVBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsInstanced;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstanced"));
    }
        dispatch_glDrawElementsInstanced1(mode, count, type, indices_buffer_offset, instanceCount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstanced}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei instanceCount); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_1</code>; <code>GL_ARB_draw_instanced</code>   */
  private native void dispatch_glDrawElementsInstanced1(int mode, int count, int type, long indices_buffer_offset, int instanceCount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedANGLE}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount); </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedANGLE(int mode, int count, int type, Buffer indices, int primcount)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsInstancedANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedANGLE"));
    }
        dispatch_glDrawElementsInstancedANGLE1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedANGLE}(GLenum mode, GLsizei count, GLenum type, const void *  indices, GLsizei primcount); </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedANGLE1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedNV}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei primcount); </code> <br>Part of <code>GL_NV_draw_instanced</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawElementsInstancedNV(int mode, int count, int type, Buffer indices, int primcount)  {

    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawElementsInstancedNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawElementsInstancedNV"));
    }
        dispatch_glDrawElementsInstancedNV1(mode, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, primcount, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawElementsInstancedNV}(GLenum mode, GLsizei count, GLenum type, const GLvoid *  indices, GLsizei primcount); </code> <br>Part of <code>GL_NV_draw_instanced</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawElementsInstancedNV1(int mode, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, int primcount, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  public void glDrawRangeElements(int mode, int start, int end, int count, int type, Buffer indices)  {

    checkElementVBOUnbound(true);
    Buffers.rangeCheck(indices, count);
    final boolean indices_is_direct = Buffers.isDirect(indices);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawRangeElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElements"));
    }
        dispatch_glDrawRangeElements1(mode, start, end, count, type, indices_is_direct ? indices : Buffers.getArray(indices), indices_is_direct ? Buffers.getDirectBufferByteOffset(indices) : Buffers.getIndirectBufferByteOffset(indices), indices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>
      @param indices a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glDrawRangeElements1(int mode, int start, int end, int count, int type, Object indices, int indices_byte_offset, boolean indices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>   */
  public void glDrawRangeElements(int mode, int start, int end, int count, int type, long indices_buffer_offset)  {

    checkElementVBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glDrawRangeElements;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glDrawRangeElements"));
    }
        dispatch_glDrawRangeElements1(mode, start, end, count, type, indices_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glDrawRangeElements}(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *  indices); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>   */
  private native void dispatch_glDrawRangeElements1(int mode, int start, int end, int count, int type, long indices_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public void glEGLImageTargetRenderbufferStorageOES(int target, long image)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEGLImageTargetRenderbufferStorageOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEGLImageTargetRenderbufferStorageOES"));
    }
        dispatch_glEGLImageTargetRenderbufferStorageOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetRenderbufferStorageOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  private native void dispatch_glEGLImageTargetRenderbufferStorageOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  public void glEGLImageTargetTexture2DOES(int target, long image)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEGLImageTargetTexture2DOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEGLImageTargetTexture2DOES"));
    }
        dispatch_glEGLImageTargetTexture2DOES1(target, image, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEGLImageTargetTexture2DOES}(GLenum target, GLeglImageOES image); </code> <br>Part of <code>GL_OES_EGL_image</code>   */
  private native void dispatch_glEGLImageTargetTexture2DOES1(int target, long image, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glEnable(int cap)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnable;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnable"));
    }
        dispatch_glEnable1(cap, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnable}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glEnable1(int cap, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glEnableDriverControlQCOM(int driverControl)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableDriverControlQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableDriverControlQCOM"));
    }
        dispatch_glEnableDriverControlQCOM1(driverControl, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableDriverControlQCOM}(GLuint driverControl); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  private native void dispatch_glEnableDriverControlQCOM1(int driverControl, long procAddress);

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glEnableVertexAttribArray(int index)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEnableVertexAttribArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEnableVertexAttribArray"));
    }
        dispatch_glEnableVertexAttribArray1(index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEnableVertexAttribArray}(GLuint index); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glEnableVertexAttribArray1(int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glEndPerfMonitorAMD(int monitor)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndPerfMonitorAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndPerfMonitorAMD"));
    }
        dispatch_glEndPerfMonitorAMD1(monitor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndPerfMonitorAMD}(GLuint monitor); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  private native void dispatch_glEndPerfMonitorAMD1(int monitor, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndQuery}(GLenum target); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  public void glEndQuery(int target)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndQuery;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndQuery"));
    }
        dispatch_glEndQuery1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndQuery}(GLenum target); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  private native void dispatch_glEndQuery1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public void glEndTilingQCOM(int preserveMask)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndTilingQCOM"));
    }
        dispatch_glEndTilingQCOM1(preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndTilingQCOM}(GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  private native void dispatch_glEndTilingQCOM1(int preserveMask, long procAddress);

  /** Entry point to C language function: <code> void {@native glEndTransformFeedback}(void); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glEndTransformFeedback()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glEndTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glEndTransformFeedback"));
    }
        dispatch_glEndTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glEndTransformFeedback}(void); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glEndTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, GLvoid *  *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glExtGetBufferPointervQCOM(int target, PointerBuffer params)  {

    if (!Buffers.isDirect(params))
      throw new GLException("Argument \"params\" is not a direct buffer");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetBufferPointervQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetBufferPointervQCOM"));
    }
        dispatch_glExtGetBufferPointervQCOM0(target, params != null ? params.getBuffer() : null, Buffers.getDirectBufferByteOffset(params), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBufferPointervQCOM}(GLenum target, GLvoid *  *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glExtGetBufferPointervQCOM0(int target, Object params, int params_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetBuffersQCOM(IntBuffer buffers, int maxBuffers, IntBuffer numBuffers)  {

    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final boolean numBuffers_is_direct = Buffers.isDirect(numBuffers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetBuffersQCOM"));
    }
        dispatch_glExtGetBuffersQCOM1(buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, maxBuffers, numBuffers_is_direct ? numBuffers : Buffers.getArray(numBuffers), numBuffers_is_direct ? Buffers.getDirectBufferByteOffset(numBuffers) : Buffers.getIndirectBufferByteOffset(numBuffers), numBuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numBuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetBuffersQCOM1(Object buffers, int buffers_byte_offset, boolean buffers_is_direct, int maxBuffers, Object numBuffers, int numBuffers_byte_offset, boolean numBuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetBuffersQCOM}(GLuint *  buffers, GLint maxBuffers, GLint *  numBuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetBuffersQCOM(int[] buffers, int buffers_offset, int maxBuffers, int[] numBuffers, int numBuffers_offset)  {

    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    if(numBuffers != null && numBuffers.length <= numBuffers_offset)
      throw new GLException("array offset argument \"numBuffers_offset\" (" + numBuffers_offset + ") equals or exceeds array length (" + numBuffers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetBuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetBuffersQCOM"));
    }
        dispatch_glExtGetBuffersQCOM1(buffers, Buffers.SIZEOF_INT * buffers_offset, false, maxBuffers, numBuffers, Buffers.SIZEOF_INT * numBuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetFramebuffersQCOM(IntBuffer framebuffers, int maxFramebuffers, IntBuffer numFramebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final boolean numFramebuffers_is_direct = Buffers.isDirect(numFramebuffers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetFramebuffersQCOM"));
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, maxFramebuffers, numFramebuffers_is_direct ? numFramebuffers : Buffers.getArray(numFramebuffers), numFramebuffers_is_direct ? Buffers.getDirectBufferByteOffset(numFramebuffers) : Buffers.getIndirectBufferByteOffset(numFramebuffers), numFramebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numFramebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetFramebuffersQCOM1(Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, int maxFramebuffers, Object numFramebuffers, int numFramebuffers_byte_offset, boolean numFramebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetFramebuffersQCOM}(GLuint *  framebuffers, GLint maxFramebuffers, GLint *  numFramebuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetFramebuffersQCOM(int[] framebuffers, int framebuffers_offset, int maxFramebuffers, int[] numFramebuffers, int numFramebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    if(numFramebuffers != null && numFramebuffers.length <= numFramebuffers_offset)
      throw new GLException("array offset argument \"numFramebuffers_offset\" (" + numFramebuffers_offset + ") equals or exceeds array length (" + numFramebuffers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetFramebuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetFramebuffersQCOM"));
    }
        dispatch_glExtGetFramebuffersQCOM1(framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, maxFramebuffers, numFramebuffers, Buffers.SIZEOF_INT * numFramebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, ByteBuffer source, IntBuffer length)  {

    final boolean source_is_direct = Buffers.isDirect(source);
    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramBinarySourceQCOM"));
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param source a direct or array-backed {@link java.nio.ByteBuffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramBinarySourceQCOM1(int program, int shadertype, Object source, int source_byte_offset, boolean source_is_direct, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramBinarySourceQCOM}(GLuint program, GLenum shadertype, GLchar *  source, GLint *  length); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public void glExtGetProgramBinarySourceQCOM(int program, int shadertype, byte[] source, int source_offset, int[] length, int length_offset)  {

    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramBinarySourceQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramBinarySourceQCOM"));
    }
        dispatch_glExtGetProgramBinarySourceQCOM1(program, shadertype, source, source_offset, false, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetProgramsQCOM(IntBuffer programs, int maxPrograms, IntBuffer numPrograms)  {

    final boolean programs_is_direct = Buffers.isDirect(programs);
    final boolean numPrograms_is_direct = Buffers.isDirect(numPrograms);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramsQCOM"));
    }
        dispatch_glExtGetProgramsQCOM1(programs_is_direct ? programs : Buffers.getArray(programs), programs_is_direct ? Buffers.getDirectBufferByteOffset(programs) : Buffers.getIndirectBufferByteOffset(programs), programs_is_direct, maxPrograms, numPrograms_is_direct ? numPrograms : Buffers.getArray(numPrograms), numPrograms_is_direct ? Buffers.getDirectBufferByteOffset(numPrograms) : Buffers.getIndirectBufferByteOffset(numPrograms), numPrograms_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param programs a direct or array-backed {@link java.nio.IntBuffer}
      @param numPrograms a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetProgramsQCOM1(Object programs, int programs_byte_offset, boolean programs_is_direct, int maxPrograms, Object numPrograms, int numPrograms_byte_offset, boolean numPrograms_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetProgramsQCOM}(GLuint *  programs, GLint maxPrograms, GLint *  numPrograms); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public void glExtGetProgramsQCOM(int[] programs, int programs_offset, int maxPrograms, int[] numPrograms, int numPrograms_offset)  {

    if(programs != null && programs.length <= programs_offset)
      throw new GLException("array offset argument \"programs_offset\" (" + programs_offset + ") equals or exceeds array length (" + programs.length + ")");
    if(numPrograms != null && numPrograms.length <= numPrograms_offset)
      throw new GLException("array offset argument \"numPrograms_offset\" (" + numPrograms_offset + ") equals or exceeds array length (" + numPrograms.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetProgramsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetProgramsQCOM"));
    }
        dispatch_glExtGetProgramsQCOM1(programs, Buffers.SIZEOF_INT * programs_offset, false, maxPrograms, numPrograms, Buffers.SIZEOF_INT * numPrograms_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetRenderbuffersQCOM(IntBuffer renderbuffers, int maxRenderbuffers, IntBuffer numRenderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final boolean numRenderbuffers_is_direct = Buffers.isDirect(numRenderbuffers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetRenderbuffersQCOM"));
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, maxRenderbuffers, numRenderbuffers_is_direct ? numRenderbuffers : Buffers.getArray(numRenderbuffers), numRenderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(numRenderbuffers) : Buffers.getIndirectBufferByteOffset(numRenderbuffers), numRenderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}
      @param numRenderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetRenderbuffersQCOM1(Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, int maxRenderbuffers, Object numRenderbuffers, int numRenderbuffers_byte_offset, boolean numRenderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetRenderbuffersQCOM}(GLuint *  renderbuffers, GLint maxRenderbuffers, GLint *  numRenderbuffers); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetRenderbuffersQCOM(int[] renderbuffers, int renderbuffers_offset, int maxRenderbuffers, int[] numRenderbuffers, int numRenderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    if(numRenderbuffers != null && numRenderbuffers.length <= numRenderbuffers_offset)
      throw new GLException("array offset argument \"numRenderbuffers_offset\" (" + numRenderbuffers_offset + ") equals or exceeds array length (" + numRenderbuffers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetRenderbuffersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetRenderbuffersQCOM"));
    }
        dispatch_glExtGetRenderbuffersQCOM1(renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, maxRenderbuffers, numRenderbuffers, Buffers.SIZEOF_INT * numRenderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetShadersQCOM(IntBuffer shaders, int maxShaders, IntBuffer numShaders)  {

    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean numShaders_is_direct = Buffers.isDirect(numShaders);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetShadersQCOM"));
    }
        dispatch_glExtGetShadersQCOM1(shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, maxShaders, numShaders_is_direct ? numShaders : Buffers.getArray(numShaders), numShaders_is_direct ? Buffers.getDirectBufferByteOffset(numShaders) : Buffers.getIndirectBufferByteOffset(numShaders), numShaders_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders); </code> <br>Part of <code>GL_QCOM_extended_get2</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param numShaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetShadersQCOM1(Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int maxShaders, Object numShaders, int numShaders_byte_offset, boolean numShaders_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetShadersQCOM}(GLuint *  shaders, GLint maxShaders, GLint *  numShaders); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public void glExtGetShadersQCOM(int[] shaders, int shaders_offset, int maxShaders, int[] numShaders, int numShaders_offset)  {

    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    if(numShaders != null && numShaders.length <= numShaders_offset)
      throw new GLException("array offset argument \"numShaders_offset\" (" + numShaders_offset + ") equals or exceeds array length (" + numShaders.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetShadersQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetShadersQCOM"));
    }
        dispatch_glExtGetShadersQCOM1(shaders, Buffers.SIZEOF_INT * shaders_offset, false, maxShaders, numShaders, Buffers.SIZEOF_INT * numShaders_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexLevelParameterivQCOM"));
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexLevelParameterivQCOM1(int texture, int face, int level, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexLevelParameterivQCOM}(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetTexLevelParameterivQCOM(int texture, int face, int level, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexLevelParameterivQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexLevelParameterivQCOM"));
    }
        dispatch_glExtGetTexLevelParameterivQCOM1(texture, face, level, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *  texels); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  public void glExtGetTexSubImageQCOM(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer texels)  {

    final boolean texels_is_direct = Buffers.isDirect(texels);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexSubImageQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexSubImageQCOM"));
    }
        dispatch_glExtGetTexSubImageQCOM1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels_is_direct ? texels : Buffers.getArray(texels), texels_is_direct ? Buffers.getDirectBufferByteOffset(texels) : Buffers.getIndirectBufferByteOffset(texels), texels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexSubImageQCOM}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *  texels); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param texels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glExtGetTexSubImageQCOM1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object texels, int texels_byte_offset, boolean texels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glExtGetTexturesQCOM(IntBuffer textures, int maxTextures, IntBuffer numTextures)  {

    final boolean textures_is_direct = Buffers.isDirect(textures);
    final boolean numTextures_is_direct = Buffers.isDirect(numTextures);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexturesQCOM"));
    }
        dispatch_glExtGetTexturesQCOM1(textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, maxTextures, numTextures_is_direct ? numTextures : Buffers.getArray(numTextures), numTextures_is_direct ? Buffers.getDirectBufferByteOffset(numTextures) : Buffers.getIndirectBufferByteOffset(numTextures), numTextures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures); </code> <br>Part of <code>GL_QCOM_extended_get</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}
      @param numTextures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glExtGetTexturesQCOM1(Object textures, int textures_byte_offset, boolean textures_is_direct, int maxTextures, Object numTextures, int numTextures_byte_offset, boolean numTextures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtGetTexturesQCOM}(GLuint *  textures, GLint maxTextures, GLint *  numTextures); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtGetTexturesQCOM(int[] textures, int textures_offset, int maxTextures, int[] numTextures, int numTextures_offset)  {

    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    if(numTextures != null && numTextures.length <= numTextures_offset)
      throw new GLException("array offset argument \"numTextures_offset\" (" + numTextures_offset + ") equals or exceeds array length (" + numTextures.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtGetTexturesQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtGetTexturesQCOM"));
    }
        dispatch_glExtGetTexturesQCOM1(textures, Buffers.SIZEOF_INT * textures_offset, false, maxTextures, numTextures, Buffers.SIZEOF_INT * numTextures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  public boolean glExtIsProgramBinaryQCOM(int program)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtIsProgramBinaryQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtIsProgramBinaryQCOM"));
    }
        return dispatch_glExtIsProgramBinaryQCOM1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glExtIsProgramBinaryQCOM}(GLuint program); </code> <br>Part of <code>GL_QCOM_extended_get2</code>   */
  private native boolean dispatch_glExtIsProgramBinaryQCOM1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  public void glExtTexObjectStateOverrideiQCOM(int target, int pname, int param)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glExtTexObjectStateOverrideiQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glExtTexObjectStateOverrideiQCOM"));
    }
        dispatch_glExtTexObjectStateOverrideiQCOM1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glExtTexObjectStateOverrideiQCOM}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_QCOM_extended_get</code>   */
  private native void dispatch_glExtTexObjectStateOverrideiQCOM1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> GLsync {@native glFenceSync}(GLenum condition, GLbitfield flags); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  public long glFenceSync(int condition, int flags)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFenceSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFenceSync"));
    }
        return dispatch_glFenceSync1(condition, flags, __addr_);
  }

  /** Entry point to C language function: <code> GLsync {@native glFenceSync}(GLenum condition, GLbitfield flags); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  private native long dispatch_glFenceSync1(int condition, int flags, long procAddress);

  /** Entry point to C language function: <code> void {@native glFinish}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glFinish()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinish;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFinish"));
    }
        dispatch_glFinish1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinish}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glFinish1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFinishFenceNV}(GLuint); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glFinishFenceNV(int arg0)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFinishFenceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFinishFenceNV"));
    }
        dispatch_glFinishFenceNV1(arg0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFinishFenceNV}(GLuint); </code> <br>Part of <code>GL_NV_fence</code>   */
  private native void dispatch_glFinishFenceNV1(int arg0, long procAddress);

  /** Entry point to C language function: <code> void {@native glFlush}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glFlush()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlush;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlush"));
    }
        dispatch_glFlush1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlush}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glFlush1(long procAddress);

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_map_buffer_range</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_map_buffer_range</code><code>GL_APPLE_flush_buffer_range</code>   */
  public void glFlushMappedBufferRange(int target, long offset, long length)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFlushMappedBufferRange;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFlushMappedBufferRange"));
    }
        dispatch_glFlushMappedBufferRange1(target, offset, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFlushMappedBufferRange}(GLenum target, GLintptr offset, GLsizeiptr length); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_map_buffer_range</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_map_buffer_range</code><code>GL_APPLE_flush_buffer_range</code>   */
  private native void dispatch_glFlushMappedBufferRange1(int target, long offset, long length, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferRenderbuffer"));
    }
        dispatch_glFramebufferRenderbuffer1(target, attachment, renderbuffertarget, renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferRenderbuffer}(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  private native void dispatch_glFramebufferRenderbuffer1(int target, int attachment, int renderbuffertarget, int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2D"));
    }
        dispatch_glFramebufferTexture2D1(target, attachment, textarget, texture, level, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  private native void dispatch_glFramebufferTexture2D1(int target, int attachment, int textarget, int texture, int level, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei); </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>   */
  public void glFramebufferTexture2DMultisampleEXT(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2DMultisampleEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2DMultisampleEXT"));
    }
        dispatch_glFramebufferTexture2DMultisampleEXT1(arg0, arg1, arg2, arg3, arg4, arg5, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleEXT}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei); </code> <br>Part of <code>GL_EXT_multisampled_render_to_texture</code>   */
  private native void dispatch_glFramebufferTexture2DMultisampleEXT1(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public void glFramebufferTexture2DMultisampleIMG(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture2DMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture2DMultisampleIMG"));
    }
        dispatch_glFramebufferTexture2DMultisampleIMG1(arg0, arg1, arg2, arg3, arg4, arg5, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture2DMultisampleIMG}(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  private native void dispatch_glFramebufferTexture2DMultisampleIMG1(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>   */
  public void glFramebufferTexture3D(int target, int attachment, int textarget, int texture, int level, int zoffset)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTexture3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTexture3D"));
    }
        dispatch_glFramebufferTexture3D1(target, attachment, textarget, texture, level, zoffset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTexture3D}(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glFramebufferTexture3D1(int target, int attachment, int textarget, int texture, int level, int zoffset, long procAddress);

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayer}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glFramebufferTextureLayer(int target, int attachment, int texture, int level, int layer)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFramebufferTextureLayer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFramebufferTextureLayer"));
    }
        dispatch_glFramebufferTextureLayer1(target, attachment, texture, level, layer, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFramebufferTextureLayer}(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glFramebufferTextureLayer1(int target, int attachment, int texture, int level, int layer, long procAddress);

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glFrontFace(int mode)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glFrontFace;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glFrontFace"));
    }
        dispatch_glFrontFace1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glFrontFace}(GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glFrontFace1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenBuffers(int n, IntBuffer buffers)  {

    Buffers.rangeCheck(buffers, n);
    final boolean buffers_is_direct = Buffers.isDirect(buffers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
    }
        dispatch_glGenBuffers1(n, buffers_is_direct ? buffers : Buffers.getArray(buffers), buffers_is_direct ? Buffers.getDirectBufferByteOffset(buffers) : Buffers.getIndirectBufferByteOffset(buffers), buffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param buffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenBuffers1(int n, Object buffers, int buffers_byte_offset, boolean buffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenBuffers}(GLsizei n, GLuint *  buffers); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGenBuffers(int n, int[] buffers, int buffers_offset)  {

    Buffers.rangeCheck(buffers, buffers_offset, n);
    if(buffers != null && buffers.length <= buffers_offset)
      throw new GLException("array offset argument \"buffers_offset\" (" + buffers_offset + ") equals or exceeds array length (" + buffers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenBuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenBuffers"));
    }
        dispatch_glGenBuffers1(n, buffers, Buffers.SIZEOF_INT * buffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei, GLuint * ); </code> <br>Part of <code>GL_NV_fence</code>
      @param arg1 a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFencesNV(int arg0, IntBuffer arg1)  {

    Buffers.rangeCheck(arg1, arg0);
    final boolean arg1_is_direct = Buffers.isDirect(arg1);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFencesNV"));
    }
        dispatch_glGenFencesNV1(arg0, arg1_is_direct ? arg1 : Buffers.getArray(arg1), arg1_is_direct ? Buffers.getDirectBufferByteOffset(arg1) : Buffers.getIndirectBufferByteOffset(arg1), arg1_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei, GLuint * ); </code> <br>Part of <code>GL_NV_fence</code>
      @param arg1 a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFencesNV1(int arg0, Object arg1, int arg1_byte_offset, boolean arg1_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFencesNV}(GLsizei, GLuint * ); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glGenFencesNV(int arg0, int[] arg1, int arg1_offset)  {

    Buffers.rangeCheck(arg1, arg1_offset, arg0);
    if(arg1 != null && arg1.length <= arg1_offset)
      throw new GLException("array offset argument \"arg1_offset\" (" + arg1_offset + ") equals or exceeds array length (" + arg1.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFencesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFencesNV"));
    }
        dispatch_glGenFencesNV1(arg0, arg1, Buffers.SIZEOF_INT * arg1_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenFramebuffers(int n, IntBuffer framebuffers)  {

    final boolean framebuffers_is_direct = Buffers.isDirect(framebuffers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
    }
        dispatch_glGenFramebuffers1(n, framebuffers_is_direct ? framebuffers : Buffers.getArray(framebuffers), framebuffers_is_direct ? Buffers.getDirectBufferByteOffset(framebuffers) : Buffers.getIndirectBufferByteOffset(framebuffers), framebuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param framebuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenFramebuffers1(int n, Object framebuffers, int framebuffers_byte_offset, boolean framebuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenFramebuffers}(GLsizei n, GLuint *  framebuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGenFramebuffers(int n, int[] framebuffers, int framebuffers_offset)  {

    if(framebuffers != null && framebuffers.length <= framebuffers_offset)
      throw new GLException("array offset argument \"framebuffers_offset\" (" + framebuffers_offset + ") equals or exceeds array length (" + framebuffers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenFramebuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenFramebuffers"));
    }
        dispatch_glGenFramebuffers1(n, framebuffers, Buffers.SIZEOF_INT * framebuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenPerfMonitorsAMD(int n, IntBuffer monitors)  {

    final boolean monitors_is_direct = Buffers.isDirect(monitors);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenPerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenPerfMonitorsAMD"));
    }
        dispatch_glGenPerfMonitorsAMD1(n, monitors_is_direct ? monitors : Buffers.getArray(monitors), monitors_is_direct ? Buffers.getDirectBufferByteOffset(monitors) : Buffers.getIndirectBufferByteOffset(monitors), monitors_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param monitors a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenPerfMonitorsAMD1(int n, Object monitors, int monitors_byte_offset, boolean monitors_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenPerfMonitorsAMD}(GLsizei n, GLuint *  monitors); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGenPerfMonitorsAMD(int n, int[] monitors, int monitors_offset)  {

    if(monitors != null && monitors.length <= monitors_offset)
      throw new GLException("array offset argument \"monitors_offset\" (" + monitors_offset + ") equals or exceeds array length (" + monitors.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenPerfMonitorsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenPerfMonitorsAMD"));
    }
        dispatch_glGenPerfMonitorsAMD1(n, monitors, Buffers.SIZEOF_INT * monitors_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenQueries(int n, IntBuffer ids)  {

    Buffers.rangeCheck(ids, n);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenQueries"));
    }
        dispatch_glGenQueries1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenQueries1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenQueries}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  public void glGenQueries(int n, int[] ids, int ids_offset)  {

    Buffers.rangeCheck(ids, ids_offset, n);
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenQueries;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenQueries"));
    }
        dispatch_glGenQueries1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenRenderbuffers(int n, IntBuffer renderbuffers)  {

    final boolean renderbuffers_is_direct = Buffers.isDirect(renderbuffers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers_is_direct ? renderbuffers : Buffers.getArray(renderbuffers), renderbuffers_is_direct ? Buffers.getDirectBufferByteOffset(renderbuffers) : Buffers.getIndirectBufferByteOffset(renderbuffers), renderbuffers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param renderbuffers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenRenderbuffers1(int n, Object renderbuffers, int renderbuffers_byte_offset, boolean renderbuffers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenRenderbuffers}(GLsizei n, GLuint *  renderbuffers); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGenRenderbuffers(int n, int[] renderbuffers, int renderbuffers_offset)  {

    if(renderbuffers != null && renderbuffers.length <= renderbuffers_offset)
      throw new GLException("array offset argument \"renderbuffers_offset\" (" + renderbuffers_offset + ") equals or exceeds array length (" + renderbuffers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenRenderbuffers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenRenderbuffers"));
    }
        dispatch_glGenRenderbuffers1(n, renderbuffers, Buffers.SIZEOF_INT * renderbuffers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenSamplers(int count, IntBuffer samplers)  {

    final boolean samplers_is_direct = Buffers.isDirect(samplers);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenSamplers"));
    }
        dispatch_glGenSamplers1(count, samplers_is_direct ? samplers : Buffers.getArray(samplers), samplers_is_direct ? Buffers.getDirectBufferByteOffset(samplers) : Buffers.getIndirectBufferByteOffset(samplers), samplers_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param samplers a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenSamplers1(int count, Object samplers, int samplers_byte_offset, boolean samplers_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenSamplers}(GLsizei count, GLuint *  samplers); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public void glGenSamplers(int count, int[] samplers, int samplers_offset)  {

    if(samplers != null && samplers.length <= samplers_offset)
      throw new GLException("array offset argument \"samplers_offset\" (" + samplers_offset + ") equals or exceeds array length (" + samplers.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenSamplers;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenSamplers"));
    }
        dispatch_glGenSamplers1(count, samplers, Buffers.SIZEOF_INT * samplers_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTextures(int n, IntBuffer textures)  {

    Buffers.rangeCheck(textures, n);
    final boolean textures_is_direct = Buffers.isDirect(textures);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
    }
        dispatch_glGenTextures1(n, textures_is_direct ? textures : Buffers.getArray(textures), textures_is_direct ? Buffers.getDirectBufferByteOffset(textures) : Buffers.getIndirectBufferByteOffset(textures), textures_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param textures a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTextures1(int n, Object textures, int textures_byte_offset, boolean textures_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTextures}(GLsizei n, GLuint *  textures); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGenTextures(int n, int[] textures, int textures_offset)  {

    Buffers.rangeCheck(textures, textures_offset, n);
    if(textures != null && textures.length <= textures_offset)
      throw new GLException("array offset argument \"textures_offset\" (" + textures_offset + ") equals or exceeds array length (" + textures.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTextures;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTextures"));
    }
        dispatch_glGenTextures1(n, textures, Buffers.SIZEOF_INT * textures_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenTransformFeedbacks(int n, IntBuffer ids)  {

    final boolean ids_is_direct = Buffers.isDirect(ids);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacks"));
    }
        dispatch_glGenTransformFeedbacks1(n, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>
      @param ids a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenTransformFeedbacks1(int n, Object ids, int ids_byte_offset, boolean ids_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenTransformFeedbacks}(GLsizei n, GLuint *  ids); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  public void glGenTransformFeedbacks(int n, int[] ids, int ids_offset)  {

    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenTransformFeedbacks;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenTransformFeedbacks"));
    }
        dispatch_glGenTransformFeedbacks1(n, ids, Buffers.SIZEOF_INT * ids_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenVertexArrays(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArrays"));
    }
        dispatch_glGenVertexArrays1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenVertexArrays1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenVertexArrays}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>   */
  public void glGenVertexArrays(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArrays;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArrays"));
    }
        dispatch_glGenVertexArrays1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGenVertexArraysOES(int n, IntBuffer arrays)  {

    final boolean arrays_is_direct = Buffers.isDirect(arrays);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArraysOES"));
    }
        dispatch_glGenVertexArraysOES1(n, arrays_is_direct ? arrays : Buffers.getArray(arrays), arrays_is_direct ? Buffers.getDirectBufferByteOffset(arrays) : Buffers.getIndirectBufferByteOffset(arrays), arrays_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>
      @param arrays a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGenVertexArraysOES1(int n, Object arrays, int arrays_byte_offset, boolean arrays_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGenVertexArraysOES}(GLsizei n, GLuint *  arrays); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public void glGenVertexArraysOES(int n, int[] arrays, int arrays_offset)  {

    if(arrays != null && arrays.length <= arrays_offset)
      throw new GLException("array offset argument \"arrays_offset\" (" + arrays_offset + ") equals or exceeds array length (" + arrays.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenVertexArraysOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenVertexArraysOES"));
    }
        dispatch_glGenVertexArraysOES1(n, arrays, Buffers.SIZEOF_INT * arrays_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGenerateMipmap(int target)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGenerateMipmap;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGenerateMipmap"));
    }
        dispatch_glGenerateMipmap1(target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGenerateMipmap}(GLenum target); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  private native void dispatch_glGenerateMipmap1(int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveAttrib(int program, int index, int bufsize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAttrib"));
    }
        dispatch_glGetActiveAttrib1(program, index, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveAttrib1(int program, int index, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveAttrib}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetActiveAttrib(int program, int index, int bufsize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveAttrib;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveAttrib"));
    }
        dispatch_glGetActiveAttrib1(program, index, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniform(int program, int index, int bufsize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniform"));
    }
        dispatch_glGetActiveUniform1(program, index, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniform1(int program, int index, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniform}(GLuint program, GLuint index, GLsizei bufsize, GLsizei *  length, GLint *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetActiveUniform(int program, int index, int bufsize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniform;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniform"));
    }
        dispatch_glGetActiveUniform1(program, index, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformBlockName a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetActiveUniformBlockName(int program, int uniformBlockIndex, int bufSize, IntBuffer length, ByteBuffer uniformBlockName)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean uniformBlockName_is_direct = Buffers.isDirect(uniformBlockName);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformBlockName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockName"));
    }
        dispatch_glGetActiveUniformBlockName1(program, uniformBlockIndex, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, uniformBlockName_is_direct ? uniformBlockName : Buffers.getArray(uniformBlockName), uniformBlockName_is_direct ? Buffers.getDirectBufferByteOffset(uniformBlockName) : Buffers.getIndirectBufferByteOffset(uniformBlockName), uniformBlockName_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param uniformBlockName a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetActiveUniformBlockName1(int program, int uniformBlockIndex, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object uniformBlockName, int uniformBlockName_byte_offset, boolean uniformBlockName_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockName}(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *  length, GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>   */
  public void glGetActiveUniformBlockName(int program, int uniformBlockIndex, int bufSize, int[] length, int length_offset, byte[] uniformBlockName, int uniformBlockName_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(uniformBlockName != null && uniformBlockName.length <= uniformBlockName_offset)
      throw new GLException("array offset argument \"uniformBlockName_offset\" (" + uniformBlockName_offset + ") equals or exceeds array length (" + uniformBlockName.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformBlockName;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockName"));
    }
        dispatch_glGetActiveUniformBlockName1(program, uniformBlockIndex, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, uniformBlockName, uniformBlockName_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveUniformBlockiv(int program, int uniformBlockIndex, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformBlockiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockiv"));
    }
        dispatch_glGetActiveUniformBlockiv1(program, uniformBlockIndex, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveUniformBlockiv1(int program, int uniformBlockIndex, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformBlockiv}(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>   */
  public void glGetActiveUniformBlockiv(int program, int uniformBlockIndex, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformBlockiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformBlockiv"));
    }
        dispatch_glGetActiveUniformBlockiv1(program, uniformBlockIndex, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetActiveUniformsiv(int program, int uniformCount, IntBuffer uniformIndices, int pname, IntBuffer params)  {

    final boolean uniformIndices_is_direct = Buffers.isDirect(uniformIndices);
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformsiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformsiv"));
    }
        dispatch_glGetActiveUniformsiv1(program, uniformCount, uniformIndices_is_direct ? uniformIndices : Buffers.getArray(uniformIndices), uniformIndices_is_direct ? Buffers.getDirectBufferByteOffset(uniformIndices) : Buffers.getIndirectBufferByteOffset(uniformIndices), uniformIndices_is_direct, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetActiveUniformsiv1(int program, int uniformCount, Object uniformIndices, int uniformIndices_byte_offset, boolean uniformIndices_is_direct, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetActiveUniformsiv}(GLuint program, GLsizei uniformCount, const GLuint *  uniformIndices, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>   */
  public void glGetActiveUniformsiv(int program, int uniformCount, int[] uniformIndices, int uniformIndices_offset, int pname, int[] params, int params_offset)  {

    if(uniformIndices != null && uniformIndices.length <= uniformIndices_offset)
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + uniformIndices_offset + ") equals or exceeds array length (" + uniformIndices.length + ")");
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetActiveUniformsiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetActiveUniformsiv"));
    }
        dispatch_glGetActiveUniformsiv1(program, uniformCount, uniformIndices, Buffers.SIZEOF_INT * uniformIndices_offset, false, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxcount, GLsizei *  count, GLuint *  shaders); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetAttachedShaders(int program, int maxcount, IntBuffer count, IntBuffer shaders)  {

    final boolean count_is_direct = Buffers.isDirect(count);
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedShaders"));
    }
        dispatch_glGetAttachedShaders1(program, maxcount, count_is_direct ? count : Buffers.getArray(count), count_is_direct ? Buffers.getDirectBufferByteOffset(count) : Buffers.getIndirectBufferByteOffset(count), count_is_direct, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxcount, GLsizei *  count, GLuint *  shaders); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param count a direct or array-backed {@link java.nio.IntBuffer}
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetAttachedShaders1(int program, int maxcount, Object count, int count_byte_offset, boolean count_is_direct, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetAttachedShaders}(GLuint program, GLsizei maxcount, GLsizei *  count, GLuint *  shaders); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetAttachedShaders(int program, int maxcount, int[] count, int count_offset, int[] shaders, int shaders_offset)  {

    if(count != null && count.length <= count_offset)
      throw new GLException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttachedShaders;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttachedShaders"));
    }
        dispatch_glGetAttachedShaders1(program, maxcount, count, Buffers.SIZEOF_INT * count_offset, false, shaders, Buffers.SIZEOF_INT * shaders_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetAttribLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public int glGetAttribLocation(int program, String name)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetAttribLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetAttribLocation"));
    }
        return dispatch_glGetAttribLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetAttribLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native int dispatch_glGetAttribLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetBooleanv(int pname, ByteBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
    }
        dispatch_glGetBooleanv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetBooleanv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBooleanv}(GLenum pname, GLboolean *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetBooleanv(int pname, byte[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBooleanv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBooleanv"));
    }
        dispatch_glGetBooleanv1(pname, params, params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetBufferParameteri64v(int target, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteri64v"));
    }
        dispatch_glGetBufferParameteri64v1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetBufferParameteri64v1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteri64v}(GLenum target, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  public void glGetBufferParameteri64v(int target, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteri64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteri64v"));
    }
        dispatch_glGetBufferParameteri64v1(target, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetBufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
    }
        dispatch_glGetBufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetBufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetBufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetBufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferParameteriv"));
    }
        dispatch_glGetBufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferPointerv}(GLenum target, GLenum pname, GLvoid *  *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_OES_mapbuffer</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glGetBufferPointerv(int target, int pname, PointerBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetBufferPointerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetBufferPointerv"));
    }
        dispatch_glGetBufferPointerv1(target, pname, params_is_direct ? ( params != null ? params.getBuffer() : null ) : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetBufferPointerv}(GLenum target, GLenum pname, GLvoid *  *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_OES_mapbuffer</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glGetBufferPointerv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLog}(GLuint count, GLsizei bufsize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_ARB_debug_output</code>; <code>GL_KHR_debug</code>
      @param sources a direct or array-backed {@link java.nio.IntBuffer}
      @param types a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param messageLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public int glGetDebugMessageLog(int count, int bufsize, IntBuffer sources, IntBuffer types, IntBuffer ids, IntBuffer severities, IntBuffer lengths, ByteBuffer messageLog)  {

    final boolean sources_is_direct = Buffers.isDirect(sources);
    final boolean types_is_direct = Buffers.isDirect(types);
    final boolean ids_is_direct = Buffers.isDirect(ids);
    final boolean severities_is_direct = Buffers.isDirect(severities);
    final boolean lengths_is_direct = Buffers.isDirect(lengths);
    final boolean messageLog_is_direct = Buffers.isDirect(messageLog);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDebugMessageLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLog"));
    }
        return dispatch_glGetDebugMessageLog1(count, bufsize, sources_is_direct ? sources : Buffers.getArray(sources), sources_is_direct ? Buffers.getDirectBufferByteOffset(sources) : Buffers.getIndirectBufferByteOffset(sources), sources_is_direct, types_is_direct ? types : Buffers.getArray(types), types_is_direct ? Buffers.getDirectBufferByteOffset(types) : Buffers.getIndirectBufferByteOffset(types), types_is_direct, ids_is_direct ? ids : Buffers.getArray(ids), ids_is_direct ? Buffers.getDirectBufferByteOffset(ids) : Buffers.getIndirectBufferByteOffset(ids), ids_is_direct, severities_is_direct ? severities : Buffers.getArray(severities), severities_is_direct ? Buffers.getDirectBufferByteOffset(severities) : Buffers.getIndirectBufferByteOffset(severities), severities_is_direct, lengths_is_direct ? lengths : Buffers.getArray(lengths), lengths_is_direct ? Buffers.getDirectBufferByteOffset(lengths) : Buffers.getIndirectBufferByteOffset(lengths), lengths_is_direct, messageLog_is_direct ? messageLog : Buffers.getArray(messageLog), messageLog_is_direct ? Buffers.getDirectBufferByteOffset(messageLog) : Buffers.getIndirectBufferByteOffset(messageLog), messageLog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLog}(GLuint count, GLsizei bufsize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_ARB_debug_output</code>; <code>GL_KHR_debug</code>
      @param sources a direct or array-backed {@link java.nio.IntBuffer}
      @param types a direct or array-backed {@link java.nio.IntBuffer}
      @param ids a direct or array-backed {@link java.nio.IntBuffer}
      @param severities a direct or array-backed {@link java.nio.IntBuffer}
      @param lengths a direct or array-backed {@link java.nio.IntBuffer}
      @param messageLog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native int dispatch_glGetDebugMessageLog1(int count, int bufsize, Object sources, int sources_byte_offset, boolean sources_is_direct, Object types, int types_byte_offset, boolean types_is_direct, Object ids, int ids_byte_offset, boolean ids_is_direct, Object severities, int severities_byte_offset, boolean severities_is_direct, Object lengths, int lengths_byte_offset, boolean lengths_is_direct, Object messageLog, int messageLog_byte_offset, boolean messageLog_is_direct, long procAddress);

  /** Entry point to C language function: <code> GLuint {@native glGetDebugMessageLog}(GLuint count, GLsizei bufsize, GLenum *  sources, GLenum *  types, GLuint *  ids, GLenum *  severities, GLsizei *  lengths, GLchar *  messageLog); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_ARB_debug_output</code>; <code>GL_KHR_debug</code>   */
  public int glGetDebugMessageLog(int count, int bufsize, int[] sources, int sources_offset, int[] types, int types_offset, int[] ids, int ids_offset, int[] severities, int severities_offset, int[] lengths, int lengths_offset, byte[] messageLog, int messageLog_offset)  {

    if(sources != null && sources.length <= sources_offset)
      throw new GLException("array offset argument \"sources_offset\" (" + sources_offset + ") equals or exceeds array length (" + sources.length + ")");
    if(types != null && types.length <= types_offset)
      throw new GLException("array offset argument \"types_offset\" (" + types_offset + ") equals or exceeds array length (" + types.length + ")");
    if(ids != null && ids.length <= ids_offset)
      throw new GLException("array offset argument \"ids_offset\" (" + ids_offset + ") equals or exceeds array length (" + ids.length + ")");
    if(severities != null && severities.length <= severities_offset)
      throw new GLException("array offset argument \"severities_offset\" (" + severities_offset + ") equals or exceeds array length (" + severities.length + ")");
    if(lengths != null && lengths.length <= lengths_offset)
      throw new GLException("array offset argument \"lengths_offset\" (" + lengths_offset + ") equals or exceeds array length (" + lengths.length + ")");
    if(messageLog != null && messageLog.length <= messageLog_offset)
      throw new GLException("array offset argument \"messageLog_offset\" (" + messageLog_offset + ") equals or exceeds array length (" + messageLog.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDebugMessageLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDebugMessageLog"));
    }
        return dispatch_glGetDebugMessageLog1(count, bufsize, sources, Buffers.SIZEOF_INT * sources_offset, false, types, Buffers.SIZEOF_INT * types_offset, false, ids, Buffers.SIZEOF_INT * ids_offset, false, severities, Buffers.SIZEOF_INT * severities_offset, false, lengths, Buffers.SIZEOF_INT * lengths_offset, false, messageLog, messageLog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, IntBuffer length, ByteBuffer driverControlString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean driverControlString_is_direct = Buffers.isDirect(driverControlString);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlStringQCOM"));
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, driverControlString_is_direct ? driverControlString : Buffers.getArray(driverControlString), driverControlString_is_direct ? Buffers.getDirectBufferByteOffset(driverControlString) : Buffers.getIndirectBufferByteOffset(driverControlString), driverControlString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControlString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetDriverControlStringQCOM1(int driverControl, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object driverControlString, int driverControlString_byte_offset, boolean driverControlString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlStringQCOM}(GLuint driverControl, GLsizei bufSize, GLsizei *  length, GLchar *  driverControlString); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glGetDriverControlStringQCOM(int driverControl, int bufSize, int[] length, int length_offset, byte[] driverControlString, int driverControlString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(driverControlString != null && driverControlString.length <= driverControlString_offset)
      throw new GLException("array offset argument \"driverControlString_offset\" (" + driverControlString_offset + ") equals or exceeds array length (" + driverControlString.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlStringQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlStringQCOM"));
    }
        dispatch_glGetDriverControlStringQCOM1(driverControl, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, driverControlString, driverControlString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetDriverControlsQCOM(IntBuffer num, int size, IntBuffer driverControls)  {

    final boolean num_is_direct = Buffers.isDirect(num);
    final boolean driverControls_is_direct = Buffers.isDirect(driverControls);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlsQCOM"));
    }
        dispatch_glGetDriverControlsQCOM1(num_is_direct ? num : Buffers.getArray(num), num_is_direct ? Buffers.getDirectBufferByteOffset(num) : Buffers.getIndirectBufferByteOffset(num), num_is_direct, size, driverControls_is_direct ? driverControls : Buffers.getArray(driverControls), driverControls_is_direct ? Buffers.getDirectBufferByteOffset(driverControls) : Buffers.getIndirectBufferByteOffset(driverControls), driverControls_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls); </code> <br>Part of <code>GL_QCOM_driver_control</code>
      @param num a direct or array-backed {@link java.nio.IntBuffer}
      @param driverControls a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetDriverControlsQCOM1(Object num, int num_byte_offset, boolean num_is_direct, int size, Object driverControls, int driverControls_byte_offset, boolean driverControls_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetDriverControlsQCOM}(GLint *  num, GLsizei size, GLuint *  driverControls); </code> <br>Part of <code>GL_QCOM_driver_control</code>   */
  public void glGetDriverControlsQCOM(int[] num, int num_offset, int size, int[] driverControls, int driverControls_offset)  {

    if(num != null && num.length <= num_offset)
      throw new GLException("array offset argument \"num_offset\" (" + num_offset + ") equals or exceeds array length (" + num.length + ")");
    if(driverControls != null && driverControls.length <= driverControls_offset)
      throw new GLException("array offset argument \"driverControls_offset\" (" + driverControls_offset + ") equals or exceeds array length (" + driverControls.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetDriverControlsQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetDriverControlsQCOM"));
    }
        dispatch_glGetDriverControlsQCOM1(num, Buffers.SIZEOF_INT * num_offset, false, size, driverControls, Buffers.SIZEOF_INT * driverControls_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public int glGetError()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetError;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetError"));
    }
        return dispatch_glGetError1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetError}(void); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native int dispatch_glGetError1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint, GLenum, GLint * ); </code> <br>Part of <code>GL_NV_fence</code>
      @param arg2 a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFenceivNV(int arg0, int arg1, IntBuffer arg2)  {

    final boolean arg2_is_direct = Buffers.isDirect(arg2);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFenceivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFenceivNV"));
    }
        dispatch_glGetFenceivNV1(arg0, arg1, arg2_is_direct ? arg2 : Buffers.getArray(arg2), arg2_is_direct ? Buffers.getDirectBufferByteOffset(arg2) : Buffers.getIndirectBufferByteOffset(arg2), arg2_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint, GLenum, GLint * ); </code> <br>Part of <code>GL_NV_fence</code>
      @param arg2 a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFenceivNV1(int arg0, int arg1, Object arg2, int arg2_byte_offset, boolean arg2_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFenceivNV}(GLuint, GLenum, GLint * ); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glGetFenceivNV(int arg0, int arg1, int[] arg2, int arg2_offset)  {

    if(arg2 != null && arg2.length <= arg2_offset)
      throw new GLException("array offset argument \"arg2_offset\" (" + arg2_offset + ") equals or exceeds array length (" + arg2.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFenceivNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFenceivNV"));
    }
        dispatch_glGetFenceivNV1(arg0, arg1, arg2, Buffers.SIZEOF_INT * arg2_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetFloatv(int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
    }
        dispatch_glGetFloatv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetFloatv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFloatv}(GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glGetFloatv(int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFloatv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFloatv"));
    }
        dispatch_glGetFloatv1(pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public int glGetFragDataLocation(int program, String name)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFragDataLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFragDataLocation"));
    }
        return dispatch_glGetFragDataLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetFragDataLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  private native int dispatch_glGetFragDataLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetFramebufferAttachmentParameteriv1(int target, int attachment, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetFramebufferAttachmentParameteriv}(GLenum target, GLenum attachment, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetFramebufferAttachmentParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetFramebufferAttachmentParameteriv"));
    }
        dispatch_glGetFramebufferAttachmentParameteriv1(target, attachment, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatus}(void); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public int glGetGraphicsResetStatus()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetGraphicsResetStatus;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetGraphicsResetStatus"));
    }
        return dispatch_glGetGraphicsResetStatus1(__addr_);
  }

  /** Entry point to C language function: <code> GLenum {@native glGetGraphicsResetStatus}(void); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  private native int dispatch_glGetGraphicsResetStatus1(long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetInteger64i_v(int target, int index, LongBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInteger64i_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64i_v"));
    }
        dispatch_glGetInteger64i_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>
      @param data a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetInteger64i_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64i_v}(GLenum target, GLuint index, GLint64 *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  public void glGetInteger64i_v(int target, int index, long[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInteger64i_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64i_v"));
    }
        dispatch_glGetInteger64i_v1(target, index, data, Buffers.SIZEOF_LONG * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetInteger64v(int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInteger64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64v"));
    }
        dispatch_glGetInteger64v1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetInteger64v1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInteger64v}(GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  public void glGetInteger64v(int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInteger64v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInteger64v"));
    }
        dispatch_glGetInteger64v1(pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegeri_v(int target, int index, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegeri_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_v"));
    }
        dispatch_glGetIntegeri_v1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegeri_v1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegeri_v}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glGetIntegeri_v(int target, int index, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegeri_v;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_v"));
    }
        dispatch_glGetIntegeri_v1(target, index, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_vEXT}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegeri_vEXT(int target, int index, IntBuffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegeri_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_vEXT"));
    }
        dispatch_glGetIntegeri_vEXT1(target, index, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegeri_vEXT}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegeri_vEXT1(int target, int index, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegeri_vEXT}(GLenum target, GLuint index, GLint *  data); </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code>   */
  public void glGetIntegeri_vEXT(int target, int index, int[] data, int data_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegeri_vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegeri_vEXT"));
    }
        dispatch_glGetIntegeri_vEXT1(target, index, data, Buffers.SIZEOF_INT * data_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetIntegerv(int pname, IntBuffer params)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
    }
        dispatch_glGetIntegerv1(pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetIntegerv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetIntegerv}(GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetIntegerv(int pname, int[] params, int params_offset)  {

    if ( glStateTracker.getInt(pname, params, params_offset) ) { return; }
    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetIntegerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetIntegerv"));
    }
        dispatch_glGetIntegerv1(pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_internalformat_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInternalformativ;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformativ"));
    }
        dispatch_glGetInternalformativ1(target, internalformat, pname, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_internalformat_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetInternalformativ1(int target, int internalformat, int pname, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetInternalformativ}(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_internalformat_query</code>   */
  public void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetInternalformativ;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetInternalformativ"));
    }
        dispatch_glGetInternalformativ1(target, internalformat, pname, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabelEXT}(GLenum type, GLuint object, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetObjectLabelEXT(int type, int object, int bufSize, IntBuffer length, ByteBuffer label)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectLabelEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabelEXT"));
    }
        dispatch_glGetObjectLabelEXT1(type, object, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabelEXT}(GLenum type, GLuint object, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetObjectLabelEXT1(int type, int object, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectLabelEXT}(GLenum type, GLuint object, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>   */
  public void glGetObjectLabelEXT(int type, int object, int bufSize, int[] length, int length_offset, byte[] label, int label_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectLabelEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabelEXT"));
    }
        dispatch_glGetObjectLabelEXT1(type, object, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabel}(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetObjectLabel(int identifier, int name, int bufSize, IntBuffer length, ByteBuffer label)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabel"));
    }
        dispatch_glGetObjectLabel1(identifier, name, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectLabel}(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetObjectLabel1(int identifier, int name, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectLabel}(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>   */
  public void glGetObjectLabel(int identifier, int name, int bufSize, int[] length, int length_offset, byte[] label, int label_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectLabel"));
    }
        dispatch_glGetObjectLabel1(identifier, name, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectPtrLabel}(const void *  ptr, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetObjectPtrLabel(Buffer ptr, int bufSize, IntBuffer length, ByteBuffer label)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectPtrLabel"));
    }
        dispatch_glGetObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetObjectPtrLabel}(const void *  ptr, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetObjectPtrLabel1(Object ptr, int ptr_byte_offset, boolean ptr_is_direct, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetObjectPtrLabel}(const void *  ptr, GLsizei bufSize, GLsizei *  length, GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetObjectPtrLabel(Buffer ptr, int bufSize, int[] length, int length_offset, byte[] label, int label_offset)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetObjectPtrLabel"));
    }
        dispatch_glGetObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorCounterDataAMD(int monitor, int pname, int dataSize, IntBuffer data, IntBuffer bytesWritten)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final boolean bytesWritten_is_direct = Buffers.isDirect(bytesWritten);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterDataAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterDataAMD"));
    }
        dispatch_glGetPerfMonitorCounterDataAMD1(monitor, pname, dataSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, bytesWritten_is_direct ? bytesWritten : Buffers.getArray(bytesWritten), bytesWritten_is_direct ? Buffers.getDirectBufferByteOffset(bytesWritten) : Buffers.getIndirectBufferByteOffset(bytesWritten), bytesWritten_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.IntBuffer}
      @param bytesWritten a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorCounterDataAMD1(int monitor, int pname, int dataSize, Object data, int data_byte_offset, boolean data_is_direct, Object bytesWritten, int bytesWritten_byte_offset, boolean bytesWritten_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterDataAMD}(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *  data, GLint *  bytesWritten); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorCounterDataAMD(int monitor, int pname, int dataSize, int[] data, int data_offset, int[] bytesWritten, int bytesWritten_offset)  {

    if(data != null && data.length <= data_offset)
      throw new GLException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    if(bytesWritten != null && bytesWritten.length <= bytesWritten_offset)
      throw new GLException("array offset argument \"bytesWritten_offset\" (" + bytesWritten_offset + ") equals or exceeds array length (" + bytesWritten.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterDataAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterDataAMD"));
    }
        dispatch_glGetPerfMonitorCounterDataAMD1(monitor, pname, dataSize, data, Buffers.SIZEOF_INT * data_offset, false, bytesWritten, Buffers.SIZEOF_INT * bytesWritten_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterInfoAMD}(GLuint group, GLuint counter, GLenum pname, GLvoid *  data); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetPerfMonitorCounterInfoAMD(int group, int counter, int pname, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterInfoAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterInfoAMD"));
    }
        dispatch_glGetPerfMonitorCounterInfoAMD1(group, counter, pname, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterInfoAMD}(GLuint group, GLuint counter, GLenum pname, GLvoid *  data); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetPerfMonitorCounterInfoAMD1(int group, int counter, int pname, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param counterString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPerfMonitorCounterStringAMD(int group, int counter, int bufSize, IntBuffer length, ByteBuffer counterString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean counterString_is_direct = Buffers.isDirect(counterString);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterStringAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterStringAMD"));
    }
        dispatch_glGetPerfMonitorCounterStringAMD1(group, counter, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, counterString_is_direct ? counterString : Buffers.getArray(counterString), counterString_is_direct ? Buffers.getDirectBufferByteOffset(counterString) : Buffers.getIndirectBufferByteOffset(counterString), counterString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param counterString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPerfMonitorCounterStringAMD1(int group, int counter, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object counterString, int counterString_byte_offset, boolean counterString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCounterStringAMD}(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *  length, GLchar *  counterString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorCounterStringAMD(int group, int counter, int bufSize, int[] length, int length_offset, byte[] counterString, int counterString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(counterString != null && counterString.length <= counterString_offset)
      throw new GLException("array offset argument \"counterString_offset\" (" + counterString_offset + ") equals or exceeds array length (" + counterString.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCounterStringAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCounterStringAMD"));
    }
        dispatch_glGetPerfMonitorCounterStringAMD1(group, counter, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, counterString, counterString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param maxActiveCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param counters a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorCountersAMD(int group, IntBuffer numCounters, IntBuffer maxActiveCounters, int counterSize, IntBuffer counters)  {

    final boolean numCounters_is_direct = Buffers.isDirect(numCounters);
    final boolean maxActiveCounters_is_direct = Buffers.isDirect(maxActiveCounters);
    final boolean counters_is_direct = Buffers.isDirect(counters);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCountersAMD"));
    }
        dispatch_glGetPerfMonitorCountersAMD1(group, numCounters_is_direct ? numCounters : Buffers.getArray(numCounters), numCounters_is_direct ? Buffers.getDirectBufferByteOffset(numCounters) : Buffers.getIndirectBufferByteOffset(numCounters), numCounters_is_direct, maxActiveCounters_is_direct ? maxActiveCounters : Buffers.getArray(maxActiveCounters), maxActiveCounters_is_direct ? Buffers.getDirectBufferByteOffset(maxActiveCounters) : Buffers.getIndirectBufferByteOffset(maxActiveCounters), maxActiveCounters_is_direct, counterSize, counters_is_direct ? counters : Buffers.getArray(counters), counters_is_direct ? Buffers.getDirectBufferByteOffset(counters) : Buffers.getIndirectBufferByteOffset(counters), counters_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param maxActiveCounters a direct or array-backed {@link java.nio.IntBuffer}
      @param counters a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorCountersAMD1(int group, Object numCounters, int numCounters_byte_offset, boolean numCounters_is_direct, Object maxActiveCounters, int maxActiveCounters_byte_offset, boolean maxActiveCounters_is_direct, int counterSize, Object counters, int counters_byte_offset, boolean counters_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorCountersAMD}(GLuint group, GLint *  numCounters, GLint *  maxActiveCounters, GLsizei counterSize, GLuint *  counters); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorCountersAMD(int group, int[] numCounters, int numCounters_offset, int[] maxActiveCounters, int maxActiveCounters_offset, int counterSize, int[] counters, int counters_offset)  {

    if(numCounters != null && numCounters.length <= numCounters_offset)
      throw new GLException("array offset argument \"numCounters_offset\" (" + numCounters_offset + ") equals or exceeds array length (" + numCounters.length + ")");
    if(maxActiveCounters != null && maxActiveCounters.length <= maxActiveCounters_offset)
      throw new GLException("array offset argument \"maxActiveCounters_offset\" (" + maxActiveCounters_offset + ") equals or exceeds array length (" + maxActiveCounters.length + ")");
    if(counters != null && counters.length <= counters_offset)
      throw new GLException("array offset argument \"counters_offset\" (" + counters_offset + ") equals or exceeds array length (" + counters.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorCountersAMD"));
    }
        dispatch_glGetPerfMonitorCountersAMD1(group, numCounters, Buffers.SIZEOF_INT * numCounters_offset, false, maxActiveCounters, Buffers.SIZEOF_INT * maxActiveCounters_offset, false, counterSize, counters, Buffers.SIZEOF_INT * counters_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param groupString a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetPerfMonitorGroupStringAMD(int group, int bufSize, IntBuffer length, ByteBuffer groupString)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean groupString_is_direct = Buffers.isDirect(groupString);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupStringAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupStringAMD"));
    }
        dispatch_glGetPerfMonitorGroupStringAMD1(group, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, groupString_is_direct ? groupString : Buffers.getArray(groupString), groupString_is_direct ? Buffers.getDirectBufferByteOffset(groupString) : Buffers.getIndirectBufferByteOffset(groupString), groupString_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param groupString a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetPerfMonitorGroupStringAMD1(int group, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object groupString, int groupString_byte_offset, boolean groupString_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupStringAMD}(GLuint group, GLsizei bufSize, GLsizei *  length, GLchar *  groupString); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorGroupStringAMD(int group, int bufSize, int[] length, int length_offset, byte[] groupString, int groupString_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(groupString != null && groupString.length <= groupString_offset)
      throw new GLException("array offset argument \"groupString_offset\" (" + groupString_offset + ") equals or exceeds array length (" + groupString.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupStringAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupStringAMD"));
    }
        dispatch_glGetPerfMonitorGroupStringAMD1(group, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, groupString, groupString_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param groups a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetPerfMonitorGroupsAMD(IntBuffer numGroups, int groupsSize, IntBuffer groups)  {

    final boolean numGroups_is_direct = Buffers.isDirect(numGroups);
    final boolean groups_is_direct = Buffers.isDirect(groups);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupsAMD"));
    }
        dispatch_glGetPerfMonitorGroupsAMD1(numGroups_is_direct ? numGroups : Buffers.getArray(numGroups), numGroups_is_direct ? Buffers.getDirectBufferByteOffset(numGroups) : Buffers.getIndirectBufferByteOffset(numGroups), numGroups_is_direct, groupsSize, groups_is_direct ? groups : Buffers.getArray(groups), groups_is_direct ? Buffers.getDirectBufferByteOffset(groups) : Buffers.getIndirectBufferByteOffset(groups), groups_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param numGroups a direct or array-backed {@link java.nio.IntBuffer}
      @param groups a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetPerfMonitorGroupsAMD1(Object numGroups, int numGroups_byte_offset, boolean numGroups_is_direct, int groupsSize, Object groups, int groups_byte_offset, boolean groups_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetPerfMonitorGroupsAMD}(GLint *  numGroups, GLsizei groupsSize, GLuint *  groups); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glGetPerfMonitorGroupsAMD(int[] numGroups, int numGroups_offset, int groupsSize, int[] groups, int groups_offset)  {

    if(numGroups != null && numGroups.length <= numGroups_offset)
      throw new GLException("array offset argument \"numGroups_offset\" (" + numGroups_offset + ") equals or exceeds array length (" + numGroups.length + ")");
    if(groups != null && groups.length <= groups_offset)
      throw new GLException("array offset argument \"groups_offset\" (" + groups_offset + ") equals or exceeds array length (" + groups.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPerfMonitorGroupsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPerfMonitorGroupsAMD"));
    }
        dispatch_glGetPerfMonitorGroupsAMD1(numGroups, Buffers.SIZEOF_INT * numGroups_offset, false, groupsSize, groups, Buffers.SIZEOF_INT * groups_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPointerv}(GLenum pname, void *  *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>; <code>GL_KHR_debug</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  public void glGetPointerv(int pname, PointerBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetPointerv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetPointerv"));
    }
        dispatch_glGetPointerv1(pname, params_is_direct ? ( params != null ? params.getBuffer() : null ) : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetPointerv}(GLenum pname, void *  *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>; <code>GL_KHR_debug</code>
      @param params a direct or array-backed {@link com.jogamp.common.nio.PointerBuffer}   */
  private native void dispatch_glGetPointerv1(int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, GLvoid *  binary); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_ARB_get_program_binary</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, IntBuffer length, IntBuffer binaryFormat, Buffer binary)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean binaryFormat_is_direct = Buffers.isDirect(binaryFormat);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramBinary"));
    }
        dispatch_glGetProgramBinary1(program, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, binaryFormat_is_direct ? binaryFormat : Buffers.getArray(binaryFormat), binaryFormat_is_direct ? Buffers.getDirectBufferByteOffset(binaryFormat) : Buffers.getIndirectBufferByteOffset(binaryFormat), binaryFormat_is_direct, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, GLvoid *  binary); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_ARB_get_program_binary</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param binaryFormat a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glGetProgramBinary1(int program, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object binaryFormat, int binaryFormat_byte_offset, boolean binaryFormat_is_direct, Object binary, int binary_byte_offset, boolean binary_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramBinary}(GLuint program, GLsizei bufSize, GLsizei *  length, GLenum *  binaryFormat, GLvoid *  binary); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_ARB_get_program_binary</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glGetProgramBinary(int program, int bufSize, int[] length, int length_offset, int[] binaryFormat, int binaryFormat_offset, Buffer binary)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(binaryFormat != null && binaryFormat.length <= binaryFormat_offset)
      throw new GLException("array offset argument \"binaryFormat_offset\" (" + binaryFormat_offset + ") equals or exceeds array length (" + binaryFormat.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramBinary"));
    }
        dispatch_glGetProgramBinary1(program, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, binaryFormat, Buffers.SIZEOF_INT * binaryFormat_offset, false, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infolog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetProgramInfoLog(int program, int bufsize, IntBuffer length, ByteBuffer infolog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infolog_is_direct = Buffers.isDirect(infolog);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInfoLog"));
    }
        dispatch_glGetProgramInfoLog1(program, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infolog_is_direct ? infolog : Buffers.getArray(infolog), infolog_is_direct ? Buffers.getDirectBufferByteOffset(infolog) : Buffers.getIndirectBufferByteOffset(infolog), infolog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infolog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetProgramInfoLog1(int program, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object infolog, int infolog_byte_offset, boolean infolog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramInfoLog}(GLuint program, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetProgramInfoLog(int program, int bufsize, int[] length, int length_offset, byte[] infolog, int infolog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infolog != null && infolog.length <= infolog_offset)
      throw new GLException("array offset argument \"infolog_offset\" (" + infolog_offset + ") equals or exceeds array length (" + infolog.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramInfoLog"));
    }
        dispatch_glGetProgramInfoLog1(program, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, infolog, infolog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetProgramiv(int program, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramiv"));
    }
        dispatch_glGetProgramiv1(program, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetProgramiv1(int program, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetProgramiv}(GLuint program, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetProgramiv(int program, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetProgramiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetProgramiv"));
    }
        dispatch_glGetProgramiv1(program, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64vEXT}(GLuint id, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjecti64vEXT(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjecti64vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64vEXT"));
    }
        dispatch_glGetQueryObjecti64vEXT1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64vEXT}(GLuint id, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjecti64vEXT1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjecti64vEXT}(GLuint id, GLenum pname, GLint64 *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  public void glGetQueryObjecti64vEXT(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjecti64vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjecti64vEXT"));
    }
        dispatch_glGetQueryObjecti64vEXT1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectivEXT}(GLuint id, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryObjectivEXT(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectivEXT"));
    }
        dispatch_glGetQueryObjectivEXT1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectivEXT}(GLuint id, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryObjectivEXT1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectivEXT}(GLuint id, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>   */
  public void glGetQueryObjectivEXT(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectivEXT"));
    }
        dispatch_glGetQueryObjectivEXT1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64vEXT}(GLuint id, GLenum pname, GLuint64 *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  public void glGetQueryObjectui64vEXT(int id, int pname, LongBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectui64vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64vEXT"));
    }
        dispatch_glGetQueryObjectui64vEXT1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64vEXT}(GLuint id, GLenum pname, GLuint64 *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.LongBuffer}   */
  private native void dispatch_glGetQueryObjectui64vEXT1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectui64vEXT}(GLuint id, GLenum pname, GLuint64 *  params); </code> <br>Part of <code>GL_EXT_timer_query</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  public void glGetQueryObjectui64vEXT(int id, int pname, long[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectui64vEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectui64vEXT"));
    }
        dispatch_glGetQueryObjectui64vEXT1(id, pname, params, Buffers.SIZEOF_LONG * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryObjectuiv(int id, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectuiv"));
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryObjectuiv1(int id, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryObjectuiv}(GLuint id, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  public void glGetQueryObjectuiv(int id, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryObjectuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryObjectuiv"));
    }
        dispatch_glGetQueryObjectuiv1(id, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetQueryiv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryiv"));
    }
        dispatch_glGetQueryiv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetQueryiv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetQueryiv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  public void glGetQueryiv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetQueryiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetQueryiv"));
    }
        dispatch_glGetQueryiv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetRenderbufferParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetRenderbufferParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetRenderbufferParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glGetRenderbufferParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetRenderbufferParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetRenderbufferParameteriv"));
    }
        dispatch_glGetRenderbufferParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetSamplerParameterfv(int sampler, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterfv"));
    }
        dispatch_glGetSamplerParameterfv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetSamplerParameterfv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameterfv}(GLuint sampler, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public void glGetSamplerParameterfv(int sampler, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameterfv"));
    }
        dispatch_glGetSamplerParameterfv1(sampler, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSamplerParameteriv(int sampler, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameteriv"));
    }
        dispatch_glGetSamplerParameteriv1(sampler, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSamplerParameteriv1(int sampler, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSamplerParameteriv}(GLuint sampler, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public void glGetSamplerParameteriv(int sampler, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSamplerParameteriv"));
    }
        dispatch_glGetSamplerParameteriv1(sampler, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infolog a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderInfoLog(int shader, int bufsize, IntBuffer length, ByteBuffer infolog)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean infolog_is_direct = Buffers.isDirect(infolog);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderInfoLog"));
    }
        dispatch_glGetShaderInfoLog1(shader, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, infolog_is_direct ? infolog : Buffers.getArray(infolog), infolog_is_direct ? Buffers.getDirectBufferByteOffset(infolog) : Buffers.getIndirectBufferByteOffset(infolog), infolog_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param infolog a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderInfoLog1(int shader, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object infolog, int infolog_byte_offset, boolean infolog_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderInfoLog}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  infolog); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetShaderInfoLog(int shader, int bufsize, int[] length, int length_offset, byte[] infolog, int infolog_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(infolog != null && infolog.length <= infolog_offset)
      throw new GLException("array offset argument \"infolog_offset\" (" + infolog_offset + ") equals or exceeds array length (" + infolog.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderInfoLog;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderInfoLog"));
    }
        dispatch_glGetShaderInfoLog1(shader, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, infolog, infolog_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, IntBuffer range, IntBuffer precision)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    final boolean range_is_direct = Buffers.isDirect(range);
    final boolean precision_is_direct = Buffers.isDirect(precision);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderPrecisionFormat"));
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range_is_direct ? range : Buffers.getArray(range), range_is_direct ? Buffers.getDirectBufferByteOffset(range) : Buffers.getIndirectBufferByteOffset(range), range_is_direct, precision_is_direct ? precision : Buffers.getArray(precision), precision_is_direct ? Buffers.getDirectBufferByteOffset(precision) : Buffers.getIndirectBufferByteOffset(precision), precision_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param range a direct or array-backed {@link java.nio.IntBuffer}
      @param precision a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderPrecisionFormat1(int shadertype, int precisiontype, Object range, int range_byte_offset, boolean range_is_direct, Object precision, int precision_byte_offset, boolean precision_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderPrecisionFormat}(GLenum shadertype, GLenum precisiontype, GLint *  range, GLint *  precision); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int[] range, int range_offset, int[] precision, int precision_offset)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glGetShaderPrecisionFormat\" not available");
    }
    if(range != null && range.length <= range_offset)
      throw new GLException("array offset argument \"range_offset\" (" + range_offset + ") equals or exceeds array length (" + range.length + ")");
    if(precision != null && precision.length <= precision_offset)
      throw new GLException("array offset argument \"precision_offset\" (" + precision_offset + ") equals or exceeds array length (" + precision.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderPrecisionFormat;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderPrecisionFormat"));
    }
        dispatch_glGetShaderPrecisionFormat1(shadertype, precisiontype, range, Buffers.SIZEOF_INT * range_offset, false, precision, Buffers.SIZEOF_INT * precision_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetShaderSource(int shader, int bufsize, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSource"));
    }
        dispatch_glGetShaderSource1(shader, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetShaderSource1(int shader, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderSource}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetShaderSource(int shader, int bufsize, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderSource"));
    }
        dispatch_glGetShaderSource1(shader, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetShaderiv(int shader, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderiv"));
    }
        dispatch_glGetShaderiv1(shader, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetShaderiv1(int shader, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetShaderiv}(GLuint shader, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetShaderiv(int shader, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetShaderiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetShaderiv"));
    }
        dispatch_glGetShaderiv1(shader, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public String glGetString(int name)  {

    if(_context.isExtensionCacheInitialized()) {
    if(GL.GL_EXTENSIONS==name) {
    return _context.getGLExtensionsString();
    } /* else if(GL.GL_VERSION==name) {
    return _context.getGLVersion();
    } */
    }
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetString;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetString"));
    }
        return dispatch_glGetString1(name, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetString}(GLenum name); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native String dispatch_glGetString1(int name, long procAddress);

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetStringi}(GLenum name, GLuint index); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public String glGetStringi(int name, int index)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetStringi;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetStringi"));
    }
        return dispatch_glGetStringi1(name, index, __addr_);
  }

  /** Entry point to C language function: <code> const GLubyte *  {@native glGetStringi}(GLenum name, GLuint index); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native String dispatch_glGetStringi1(int name, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetSynciv(long sync, int pname, int bufSize, IntBuffer length, IntBuffer values)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSynciv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSynciv"));
    }
        dispatch_glGetSynciv1(sync, pname, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param values a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetSynciv1(long sync, int pname, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetSynciv}(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *  length, GLint *  values); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  public void glGetSynciv(long sync, int pname, int bufSize, int[] length, int length_offset, int[] values, int values_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetSynciv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetSynciv"));
    }
        dispatch_glGetSynciv1(sync, pname, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, values, Buffers.SIZEOF_INT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
    }
        dispatch_glGetTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameterfv}(GLenum target, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glGetTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameterfv"));
    }
        dispatch_glGetTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
    }
        dispatch_glGetTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTexParameteriv}(GLenum target, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glGetTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTexParameteriv"));
    }
        dispatch_glGetTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetTransformFeedbackVarying(int program, int index, int bufSize, IntBuffer length, IntBuffer size, IntBuffer type, ByteBuffer name)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean size_is_direct = Buffers.isDirect(size);
    final boolean type_is_direct = Buffers.isDirect(type);
    final boolean name_is_direct = Buffers.isDirect(name);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTransformFeedbackVarying;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackVarying"));
    }
        dispatch_glGetTransformFeedbackVarying1(program, index, bufSize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, size_is_direct ? size : Buffers.getArray(size), size_is_direct ? Buffers.getDirectBufferByteOffset(size) : Buffers.getIndirectBufferByteOffset(size), size_is_direct, type_is_direct ? type : Buffers.getArray(type), type_is_direct ? Buffers.getDirectBufferByteOffset(type) : Buffers.getIndirectBufferByteOffset(type), type_is_direct, name_is_direct ? name : Buffers.getArray(name), name_is_direct ? Buffers.getDirectBufferByteOffset(name) : Buffers.getIndirectBufferByteOffset(name), name_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param size a direct or array-backed {@link java.nio.IntBuffer}
      @param type a direct or array-backed {@link java.nio.IntBuffer}
      @param name a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetTransformFeedbackVarying1(int program, int index, int bufSize, Object length, int length_byte_offset, boolean length_is_direct, Object size, int size_byte_offset, boolean size_is_direct, Object type, int type_byte_offset, boolean type_is_direct, Object name, int name_byte_offset, boolean name_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTransformFeedbackVarying}(GLuint program, GLuint index, GLsizei bufSize, GLsizei *  length, GLsizei *  size, GLenum *  type, GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glGetTransformFeedbackVarying(int program, int index, int bufSize, int[] length, int length_offset, int[] size, int size_offset, int[] type, int type_offset, byte[] name, int name_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(size != null && size.length <= size_offset)
      throw new GLException("array offset argument \"size_offset\" (" + size_offset + ") equals or exceeds array length (" + size.length + ")");
    if(type != null && type.length <= type_offset)
      throw new GLException("array offset argument \"type_offset\" (" + type_offset + ") equals or exceeds array length (" + type.length + ")");
    if(name != null && name.length <= name_offset)
      throw new GLException("array offset argument \"name_offset\" (" + name_offset + ") equals or exceeds array length (" + name.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTransformFeedbackVarying;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTransformFeedbackVarying"));
    }
        dispatch_glGetTransformFeedbackVarying1(program, index, bufSize, length, Buffers.SIZEOF_INT * length_offset, false, size, Buffers.SIZEOF_INT * size_offset, false, type, Buffers.SIZEOF_INT * type_offset, false, name, name_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTranslatedShaderSourceANGLE}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_ANGLE_translated_shader_source</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glGetTranslatedShaderSourceANGLE(int shader, int bufsize, IntBuffer length, ByteBuffer source)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final boolean source_is_direct = Buffers.isDirect(source);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTranslatedShaderSourceANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTranslatedShaderSourceANGLE"));
    }
        dispatch_glGetTranslatedShaderSourceANGLE1(shader, bufsize, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, source_is_direct ? source : Buffers.getArray(source), source_is_direct ? Buffers.getDirectBufferByteOffset(source) : Buffers.getIndirectBufferByteOffset(source), source_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetTranslatedShaderSourceANGLE}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_ANGLE_translated_shader_source</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}
      @param source a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glGetTranslatedShaderSourceANGLE1(int shader, int bufsize, Object length, int length_byte_offset, boolean length_is_direct, Object source, int source_byte_offset, boolean source_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetTranslatedShaderSourceANGLE}(GLuint shader, GLsizei bufsize, GLsizei *  length, GLchar *  source); </code> <br>Part of <code>GL_ANGLE_translated_shader_source</code>   */
  public void glGetTranslatedShaderSourceANGLE(int shader, int bufsize, int[] length, int length_offset, byte[] source, int source_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    if(source != null && source.length <= source_offset)
      throw new GLException("array offset argument \"source_offset\" (" + source_offset + ") equals or exceeds array length (" + source.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetTranslatedShaderSourceANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetTranslatedShaderSourceANGLE"));
    }
        dispatch_glGetTranslatedShaderSourceANGLE1(shader, bufsize, length, Buffers.SIZEOF_INT * length_offset, false, source, source_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetUniformBlockIndex}(GLuint program, const GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>   */
  public int glGetUniformBlockIndex(int program, String uniformBlockName)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformBlockIndex;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformBlockIndex"));
    }
        return dispatch_glGetUniformBlockIndex1(program, uniformBlockName, __addr_);
  }

  /** Entry point to C language function: <code> GLuint {@native glGetUniformBlockIndex}(GLuint program, const GLchar *  uniformBlockName); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>   */
  private native int dispatch_glGetUniformBlockIndex1(int program, String uniformBlockName, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar * const  *  uniformNames, GLuint *  uniformIndices); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformIndices(int program, int uniformCount, String[] uniformNames, IntBuffer uniformIndices)  {

    final boolean uniformIndices_is_direct = Buffers.isDirect(uniformIndices);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformIndices;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformIndices"));
    }
        dispatch_glGetUniformIndices1(program, uniformCount, uniformNames, uniformIndices_is_direct ? uniformIndices : Buffers.getArray(uniformIndices), uniformIndices_is_direct ? Buffers.getDirectBufferByteOffset(uniformIndices) : Buffers.getIndirectBufferByteOffset(uniformIndices), uniformIndices_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar * const  *  uniformNames, GLuint *  uniformIndices); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>
      @param uniformIndices a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformIndices1(int program, int uniformCount, String[] uniformNames, Object uniformIndices, int uniformIndices_byte_offset, boolean uniformIndices_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformIndices}(GLuint program, GLsizei uniformCount, const GLchar * const  *  uniformNames, GLuint *  uniformIndices); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>   */
  public void glGetUniformIndices(int program, int uniformCount, String[] uniformNames, int[] uniformIndices, int uniformIndices_offset)  {

    if(uniformIndices != null && uniformIndices.length <= uniformIndices_offset)
      throw new GLException("array offset argument \"uniformIndices_offset\" (" + uniformIndices_offset + ") equals or exceeds array length (" + uniformIndices.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformIndices;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformIndices"));
    }
        dispatch_glGetUniformIndices1(program, uniformCount, uniformNames, uniformIndices, Buffers.SIZEOF_INT * uniformIndices_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public int glGetUniformLocation(int program, String name)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformLocation;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformLocation"));
    }
        return dispatch_glGetUniformLocation1(program, name, __addr_);
  }

  /** Entry point to C language function: <code> GLint {@native glGetUniformLocation}(GLuint program, const GLchar *  name); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native int dispatch_glGetUniformLocation1(int program, String name, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetUniformfv(int program, int location, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfv"));
    }
        dispatch_glGetUniformfv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetUniformfv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformfv}(GLuint program, GLint location, GLfloat *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetUniformfv(int program, int location, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformfv"));
    }
        dispatch_glGetUniformfv1(program, location, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformiv"));
    }
        dispatch_glGetUniformiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformiv}(GLuint program, GLint location, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetUniformiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformiv"));
    }
        dispatch_glGetUniformiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetUniformuiv(int program, int location, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformuiv"));
    }
        dispatch_glGetUniformuiv1(program, location, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetUniformuiv1(int program, int location, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetUniformuiv}(GLuint program, GLint location, GLuint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glGetUniformuiv(int program, int location, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetUniformuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetUniformuiv"));
    }
        dispatch_glGetUniformuiv1(program, location, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIiv"));
    }
        dispatch_glGetVertexAttribIiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glGetVertexAttribIiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIiv"));
    }
        dispatch_glGetVertexAttribIiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribIuiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuiv"));
    }
        dispatch_glGetVertexAttribIuiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribIuiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribIuiv}(GLuint index, GLenum pname, GLuint *  params); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glGetVertexAttribIuiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribIuiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribIuiv"));
    }
        dispatch_glGetVertexAttribIuiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetVertexAttribfv(int index, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfv"));
    }
        dispatch_glGetVertexAttribfv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetVertexAttribfv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribfv}(GLuint index, GLenum pname, GLfloat *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetVertexAttribfv(int index, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribfv"));
    }
        dispatch_glGetVertexAttribfv1(index, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetVertexAttribiv(int index, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribiv"));
    }
        dispatch_glGetVertexAttribiv1(index, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetVertexAttribiv1(int index, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetVertexAttribiv}(GLuint index, GLenum pname, GLint *  params); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glGetVertexAttribiv(int index, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetVertexAttribiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetVertexAttribiv"));
    }
        dispatch_glGetVertexAttribiv1(index, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, float *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glGetnUniformfv(int program, int location, int bufSize, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, float *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glGetnUniformfv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformfv}(GLuint program, GLint location, GLsizei bufSize, float *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public void glGetnUniformfv(int program, int location, int bufSize, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformfv"));
    }
        dispatch_glGetnUniformfv1(program, location, bufSize, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glGetnUniformiv(int program, int location, int bufSize, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glGetnUniformiv1(int program, int location, int bufSize, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glGetnUniformiv}(GLuint program, GLint location, GLsizei bufSize, GLint *  params); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>   */
  public void glGetnUniformiv(int program, int location, int bufSize, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glGetnUniformiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glGetnUniformiv"));
    }
        dispatch_glGetnUniformiv1(program, location, bufSize, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glHint(int target, int mode)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glHint;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glHint"));
    }
        dispatch_glHint1(target, mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glHint}(GLenum target, GLenum mode); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glHint1(int target, int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glInsertEventMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>
      @param marker a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glInsertEventMarkerEXT(int length, ByteBuffer marker)  {

    final boolean marker_is_direct = Buffers.isDirect(marker);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glInsertEventMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInsertEventMarkerEXT"));
    }
        dispatch_glInsertEventMarkerEXT1(length, marker_is_direct ? marker : Buffers.getArray(marker), marker_is_direct ? Buffers.getDirectBufferByteOffset(marker) : Buffers.getIndirectBufferByteOffset(marker), marker_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInsertEventMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>
      @param marker a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glInsertEventMarkerEXT1(int length, Object marker, int marker_byte_offset, boolean marker_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glInsertEventMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>   */
  public void glInsertEventMarkerEXT(int length, byte[] marker, int marker_offset)  {

    if(marker != null && marker.length <= marker_offset)
      throw new GLException("array offset argument \"marker_offset\" (" + marker_offset + ") equals or exceeds array length (" + marker.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glInsertEventMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInsertEventMarkerEXT"));
    }
        dispatch_glInsertEventMarkerEXT1(length, marker, marker_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glInvalidateFramebuffer(int target, int numAttachments, IntBuffer attachments)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glInvalidateFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateFramebuffer"));
    }
        dispatch_glInvalidateFramebuffer1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glInvalidateFramebuffer1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>   */
  public void glInvalidateFramebuffer(int target, int numAttachments, int[] attachments, int attachments_offset)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glInvalidateFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateFramebuffer"));
    }
        dispatch_glInvalidateFramebuffer1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateSubFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glInvalidateSubFramebuffer(int target, int numAttachments, IntBuffer attachments, int x, int y, int width, int height)  {

    final boolean attachments_is_direct = Buffers.isDirect(attachments);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glInvalidateSubFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateSubFramebuffer"));
    }
        dispatch_glInvalidateSubFramebuffer1(target, numAttachments, attachments_is_direct ? attachments : Buffers.getArray(attachments), attachments_is_direct ? Buffers.getDirectBufferByteOffset(attachments) : Buffers.getIndirectBufferByteOffset(attachments), attachments_is_direct, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glInvalidateSubFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>
      @param attachments a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glInvalidateSubFramebuffer1(int target, int numAttachments, Object attachments, int attachments_byte_offset, boolean attachments_is_direct, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glInvalidateSubFramebuffer}(GLenum target, GLsizei numAttachments, const GLenum *  attachments, GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_invalidate_subdata</code>, <code>GL_VERSION_4_3</code>   */
  public void glInvalidateSubFramebuffer(int target, int numAttachments, int[] attachments, int attachments_offset, int x, int y, int width, int height)  {

    if(attachments != null && attachments.length <= attachments_offset)
      throw new GLException("array offset argument \"attachments_offset\" (" + attachments_offset + ") equals or exceeds array length (" + attachments.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glInvalidateSubFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glInvalidateSubFramebuffer"));
    }
        dispatch_glInvalidateSubFramebuffer1(target, numAttachments, attachments, Buffers.SIZEOF_INT * attachments_offset, false, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsBuffer(int buffer)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsBuffer"));
    }
        return dispatch_glIsBuffer1(buffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsBuffer}(GLuint buffer); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_5</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native boolean dispatch_glIsBuffer1(int buffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsEnabled(int cap)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsEnabled;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsEnabled"));
    }
        return dispatch_glIsEnabled1(cap, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsEnabled}(GLenum cap); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_NV_vertex_buffer_unified_memory</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native boolean dispatch_glIsEnabled1(int cap, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceNV}(GLuint); </code> <br>Part of <code>GL_NV_fence</code>   */
  public boolean glIsFenceNV(int arg0)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsFenceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsFenceNV"));
    }
        return dispatch_glIsFenceNV1(arg0, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFenceNV}(GLuint); </code> <br>Part of <code>GL_NV_fence</code>   */
  private native boolean dispatch_glIsFenceNV1(int arg0, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public boolean glIsFramebuffer(int framebuffer)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsFramebuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsFramebuffer"));
    }
        return dispatch_glIsFramebuffer1(framebuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsFramebuffer}(GLuint framebuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  private native boolean dispatch_glIsFramebuffer1(int framebuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public boolean glIsProgram(int program)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsProgram"));
    }
        return dispatch_glIsProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native boolean dispatch_glIsProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsQuery}(GLuint id); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  public boolean glIsQuery(int id)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsQuery;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsQuery"));
    }
        return dispatch_glIsQuery1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsQuery}(GLuint id); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_5</code>; <code>GL_EXT_occlusion_query_boolean</code>, <code>GL_EXT_disjoint_timer_query</code>   */
  private native boolean dispatch_glIsQuery1(int id, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public boolean glIsRenderbuffer(int renderbuffer)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsRenderbuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsRenderbuffer"));
    }
        return dispatch_glIsRenderbuffer1(renderbuffer, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsRenderbuffer}(GLuint renderbuffer); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  private native boolean dispatch_glIsRenderbuffer1(int renderbuffer, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsSampler}(GLuint sampler); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public boolean glIsSampler(int sampler)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsSampler;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsSampler"));
    }
        return dispatch_glIsSampler1(sampler, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSampler}(GLuint sampler); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  private native boolean dispatch_glIsSampler1(int sampler, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public boolean glIsShader(int shader)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsShader;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsShader"));
    }
        return dispatch_glIsShader1(shader, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsShader}(GLuint shader); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native boolean dispatch_glIsShader1(int shader, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsSync}(GLsync sync); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  public boolean glIsSync(long sync)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsSync"));
    }
        return dispatch_glIsSync1(sync, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsSync}(GLsync sync); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  private native boolean dispatch_glIsSync1(long sync, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public boolean glIsTexture(int texture)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsTexture;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsTexture"));
    }
        return dispatch_glIsTexture1(texture, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTexture}(GLuint texture); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native boolean dispatch_glIsTexture1(int texture, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedback}(GLuint id); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  public boolean glIsTransformFeedback(int id)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsTransformFeedback"));
    }
        return dispatch_glIsTransformFeedback1(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsTransformFeedback}(GLuint id); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  private native boolean dispatch_glIsTransformFeedback1(int id, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArray}(GLuint array); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>   */
  public boolean glIsVertexArray(int array)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsVertexArray;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsVertexArray"));
    }
        return dispatch_glIsVertexArray1(array, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArray}(GLuint array); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_vertex_array_object</code>, <code>GL_VERSION_3_0</code>   */
  private native boolean dispatch_glIsVertexArray1(int array, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  public boolean glIsVertexArrayOES(int array)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glIsVertexArrayOES;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glIsVertexArrayOES"));
    }
        return dispatch_glIsVertexArrayOES1(array, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glIsVertexArrayOES}(GLuint array); </code> <br>Part of <code>GL_OES_vertex_array_object</code>   */
  private native boolean dispatch_glIsVertexArrayOES1(int array, long procAddress);

  /** Entry point to C language function: <code> void {@native glLabelObjectEXT}(GLenum type, GLuint object, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glLabelObjectEXT(int type, int object, int length, ByteBuffer label)  {

    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLabelObjectEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLabelObjectEXT"));
    }
        dispatch_glLabelObjectEXT1(type, object, length, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLabelObjectEXT}(GLenum type, GLuint object, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glLabelObjectEXT1(int type, int object, int length, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glLabelObjectEXT}(GLenum type, GLuint object, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_EXT_debug_label</code>   */
  public void glLabelObjectEXT(int type, int object, int length, byte[] label, int label_offset)  {

    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLabelObjectEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLabelObjectEXT"));
    }
        dispatch_glLabelObjectEXT1(type, object, length, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glLineWidth(float width)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLineWidth;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLineWidth"));
    }
        dispatch_glLineWidth1(width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLineWidth}(GLfloat width); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  private native void dispatch_glLineWidth1(float width, long procAddress);

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glLinkProgram(int program)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glLinkProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glLinkProgram"));
    }
        dispatch_glLinkProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glLinkProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glLinkProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glObjectLabel}(GLenum identifier, GLuint name, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glObjectLabel(int identifier, int name, int length, ByteBuffer label)  {

    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectLabel"));
    }
        dispatch_glObjectLabel1(identifier, name, length, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glObjectLabel}(GLenum identifier, GLuint name, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glObjectLabel1(int identifier, int name, int length, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glObjectLabel}(GLenum identifier, GLuint name, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>   */
  public void glObjectLabel(int identifier, int name, int length, byte[] label, int label_offset)  {

    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glObjectLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectLabel"));
    }
        dispatch_glObjectLabel1(identifier, name, length, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glObjectPtrLabel}(const void *  ptr, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glObjectPtrLabel(Buffer ptr, int length, ByteBuffer label)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    final boolean label_is_direct = Buffers.isDirect(label);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectPtrLabel"));
    }
        dispatch_glObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, length, label_is_direct ? label : Buffers.getArray(label), label_is_direct ? Buffers.getDirectBufferByteOffset(label) : Buffers.getIndirectBufferByteOffset(label), label_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glObjectPtrLabel}(const void *  ptr, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}
      @param label a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glObjectPtrLabel1(Object ptr, int ptr_byte_offset, boolean ptr_is_direct, int length, Object label, int label_byte_offset, boolean label_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glObjectPtrLabel}(const void *  ptr, GLsizei length, const GLchar *  label); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param ptr a direct or array-backed {@link java.nio.Buffer}   */
  public void glObjectPtrLabel(Buffer ptr, int length, byte[] label, int label_offset)  {

    final boolean ptr_is_direct = Buffers.isDirect(ptr);
    if(label != null && label.length <= label_offset)
      throw new GLException("array offset argument \"label_offset\" (" + label_offset + ") equals or exceeds array length (" + label.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glObjectPtrLabel;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glObjectPtrLabel"));
    }
        dispatch_glObjectPtrLabel1(ptr_is_direct ? ptr : Buffers.getArray(ptr), ptr_is_direct ? Buffers.getDirectBufferByteOffset(ptr) : Buffers.getIndirectBufferByteOffset(ptr), ptr_is_direct, length, label, label_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedback}(void); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  public void glPauseTransformFeedback()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPauseTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPauseTransformFeedback"));
    }
        dispatch_glPauseTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPauseTransformFeedback}(void); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  private native void dispatch_glPauseTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glPixelStorei(int pname, int param)  {

    if (pname != GL_PACK_ALIGNMENT && pname != GL_UNPACK_ALIGNMENT) {
    throw new GLException("Unsupported pixel store parameter name 0x" + Integer.toHexString(pname));
    }
    glStateTracker.setInt(pname, param);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPixelStorei;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPixelStorei"));
    }
        dispatch_glPixelStorei1(pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPixelStorei}(GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glPixelStorei1(int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glPolygonOffset(float factor, float units)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPolygonOffset;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPolygonOffset"));
    }
        dispatch_glPolygonOffset1(factor, units, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPolygonOffset}(GLfloat factor, GLfloat units); </code> <br>Part of <code>GL_VERSION_1_1</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  private native void dispatch_glPolygonOffset1(float factor, float units, long procAddress);

  /** Entry point to C language function: <code> void {@native glPopDebugGroup}(void); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>   */
  public void glPopDebugGroup()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPopDebugGroup;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPopDebugGroup"));
    }
        dispatch_glPopDebugGroup1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopDebugGroup}(void); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>   */
  private native void dispatch_glPopDebugGroup1(long procAddress);

  /** Entry point to C language function: <code> void {@native glPopGroupMarkerEXT}(void); </code> <br>Part of <code>GL_EXT_debug_marker</code>   */
  public void glPopGroupMarkerEXT()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPopGroupMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPopGroupMarkerEXT"));
    }
        dispatch_glPopGroupMarkerEXT1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glPopGroupMarkerEXT}(void); </code> <br>Part of <code>GL_EXT_debug_marker</code>   */
  private native void dispatch_glPopGroupMarkerEXT1(long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramBinary}(GLuint program, GLenum binaryFormat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_ARB_get_program_binary</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glProgramBinary(int program, int binaryFormat, Buffer binary, int length)  {

    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramBinary"));
    }
        dispatch_glProgramBinary1(program, binaryFormat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramBinary}(GLuint program, GLenum binaryFormat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_ARB_get_program_binary</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glProgramBinary1(int program, int binaryFormat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glProgramParameteri}(GLuint program, GLenum pname, GLint value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_ARB_get_program_binary</code>; <code>GL_EXT_separate_shader_objects</code>, <code>GL_EXT_geometry_shader4</code>   */
  public void glProgramParameteri(int program, int pname, int value)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glProgramParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glProgramParameteri"));
    }
        dispatch_glProgramParameteri1(program, pname, value, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glProgramParameteri}(GLuint program, GLenum pname, GLint value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_1</code>, <code>GL_ARB_get_program_binary</code>; <code>GL_EXT_separate_shader_objects</code>, <code>GL_EXT_geometry_shader4</code>   */
  private native void dispatch_glProgramParameteri1(int program, int pname, int value, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushDebugGroup}(GLenum source, GLuint id, GLsizei length, const GLchar *  message); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glPushDebugGroup(int source, int id, int length, ByteBuffer message)  {

    final boolean message_is_direct = Buffers.isDirect(message);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushDebugGroup;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushDebugGroup"));
    }
        dispatch_glPushDebugGroup1(source, id, length, message_is_direct ? message : Buffers.getArray(message), message_is_direct ? Buffers.getDirectBufferByteOffset(message) : Buffers.getIndirectBufferByteOffset(message), message_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushDebugGroup}(GLenum source, GLuint id, GLsizei length, const GLchar *  message); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>
      @param message a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glPushDebugGroup1(int source, int id, int length, Object message, int message_byte_offset, boolean message_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushDebugGroup}(GLenum source, GLuint id, GLsizei length, const GLchar *  message); </code> <br>Part of <code>GL_VERSION_4_3</code>, <code>GL_KHR_debug</code>; <code>GL_KHR_debug</code>   */
  public void glPushDebugGroup(int source, int id, int length, byte[] message, int message_offset)  {

    if(message != null && message.length <= message_offset)
      throw new GLException("array offset argument \"message_offset\" (" + message_offset + ") equals or exceeds array length (" + message.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushDebugGroup;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushDebugGroup"));
    }
        dispatch_glPushDebugGroup1(source, id, length, message, message_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushGroupMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>
      @param marker a direct or array-backed {@link java.nio.ByteBuffer}   */
  public void glPushGroupMarkerEXT(int length, ByteBuffer marker)  {

    final boolean marker_is_direct = Buffers.isDirect(marker);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushGroupMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushGroupMarkerEXT"));
    }
        dispatch_glPushGroupMarkerEXT1(length, marker_is_direct ? marker : Buffers.getArray(marker), marker_is_direct ? Buffers.getDirectBufferByteOffset(marker) : Buffers.getIndirectBufferByteOffset(marker), marker_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glPushGroupMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>
      @param marker a direct or array-backed {@link java.nio.ByteBuffer}   */
  private native void dispatch_glPushGroupMarkerEXT1(int length, Object marker, int marker_byte_offset, boolean marker_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glPushGroupMarkerEXT}(GLsizei length, const GLchar *  marker); </code> <br>Part of <code>GL_EXT_debug_marker</code>   */
  public void glPushGroupMarkerEXT(int length, byte[] marker, int marker_offset)  {

    if(marker != null && marker.length <= marker_offset)
      throw new GLException("array offset argument \"marker_offset\" (" + marker_offset + ") equals or exceeds array length (" + marker.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glPushGroupMarkerEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glPushGroupMarkerEXT"));
    }
        dispatch_glPushGroupMarkerEXT1(length, marker, marker_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glQueryCounterEXT}(GLuint id, GLenum target); </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>   */
  public void glQueryCounterEXT(int id, int target)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glQueryCounterEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glQueryCounterEXT"));
    }
        dispatch_glQueryCounterEXT1(id, target, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glQueryCounterEXT}(GLuint id, GLenum target); </code> <br>Part of <code>GL_EXT_disjoint_timer_query</code>   */
  private native void dispatch_glQueryCounterEXT1(int id, int target, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadBuffer}(GLenum mode); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_0</code>   */
  public void glReadBuffer(int mode)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadBuffer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadBuffer"));
    }
        dispatch_glReadBuffer1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBuffer}(GLenum mode); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_1_0</code>   */
  private native void dispatch_glReadBuffer1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadBufferIndexedEXT}(GLenum src, GLint index); </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code>   */
  public void glReadBufferIndexedEXT(int src, int index)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadBufferIndexedEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadBufferIndexedEXT"));
    }
        dispatch_glReadBufferIndexedEXT1(src, index, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBufferIndexedEXT}(GLenum src, GLint index); </code> <br>Part of <code>GL_EXT_multiview_draw_buffers</code>   */
  private native void dispatch_glReadBufferIndexedEXT1(int src, int index, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadBufferNV}(GLenum mode); </code> <br>Part of <code>GL_NV_read_buffer</code>   */
  public void glReadBufferNV(int mode)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadBufferNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadBufferNV"));
    }
        dispatch_glReadBufferNV1(mode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadBufferNV}(GLenum mode); </code> <br>Part of <code>GL_NV_read_buffer</code>   */
  private native void dispatch_glReadBufferNV1(int mode, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, Buffer pixels)  {

    checkPackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , true));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glReadPixels(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkPackPBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadPixels"));
    }
        dispatch_glReadPixels1(x, y, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glReadPixels1(int x, int y, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glReadnPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  public void glReadnPixels(int x, int y, int width, int height, int format, int type, int bufSize, Buffer data)  {

    final boolean data_is_direct = Buffers.isDirect(data);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReadnPixels;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReadnPixels"));
    }
        dispatch_glReadnPixels1(x, y, width, height, format, type, bufSize, data_is_direct ? data : Buffers.getArray(data), data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), data_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glReadnPixels}(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *  data); </code> <br>Part of <code>GL_ARB_robustness</code>; <code>GL_EXT_robustness</code>
      @param data a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glReadnPixels1(int x, int y, int width, int height, int format, int type, int bufSize, Object data, int data_byte_offset, boolean data_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glReleaseShaderCompiler()  {

    if ( !_context.isGLES2Compatible() ) {
    return;
    }
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glReleaseShaderCompiler;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glReleaseShaderCompiler"));
    }
        dispatch_glReleaseShaderCompiler1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glReleaseShaderCompiler}(void); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glReleaseShaderCompiler1(long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  public void glRenderbufferStorage(int target, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorage"));
    }
        dispatch_glRenderbufferStorage1(target, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorage}(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_VERSION_3_0</code>, <code>GL_ES_VERSION_2_0</code>; <code>GL_OES_framebuffer_object</code>   */
  private native void dispatch_glRenderbufferStorage1(int target, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glRenderbufferStorageMultisample(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisample;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisample"));
    }
        dispatch_glRenderbufferStorageMultisample1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisample}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ARB_framebuffer_object</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glRenderbufferStorageMultisample1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleANGLE}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ANGLE_framebuffer_multisample</code>   */
  public void glRenderbufferStorageMultisampleANGLE(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleANGLE"));
    }
        dispatch_glRenderbufferStorageMultisampleANGLE1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleANGLE}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ANGLE_framebuffer_multisample</code>   */
  private native void dispatch_glRenderbufferStorageMultisampleANGLE1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleAPPLE}(GLenum, GLsizei, GLenum, GLsizei, GLsizei); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public void glRenderbufferStorageMultisampleAPPLE(int arg0, int arg1, int arg2, int arg3, int arg4)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleAPPLE"));
    }
        dispatch_glRenderbufferStorageMultisampleAPPLE1(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleAPPLE}(GLenum, GLsizei, GLenum, GLsizei, GLsizei); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  private native void dispatch_glRenderbufferStorageMultisampleAPPLE1(int arg0, int arg1, int arg2, int arg3, int arg4, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum, GLsizei, GLenum, GLsizei, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  public void glRenderbufferStorageMultisampleIMG(int arg0, int arg1, int arg2, int arg3, int arg4)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleIMG;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleIMG"));
    }
        dispatch_glRenderbufferStorageMultisampleIMG1(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleIMG}(GLenum, GLsizei, GLenum, GLsizei, GLsizei); </code> <br>Part of <code>GL_IMG_multisampled_render_to_texture</code>   */
  private native void dispatch_glRenderbufferStorageMultisampleIMG1(int arg0, int arg1, int arg2, int arg3, int arg4, long procAddress);

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleNV}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_NV_framebuffer_multisample</code>   */
  public void glRenderbufferStorageMultisampleNV(int target, int samples, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glRenderbufferStorageMultisampleNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glRenderbufferStorageMultisampleNV"));
    }
        dispatch_glRenderbufferStorageMultisampleNV1(target, samples, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glRenderbufferStorageMultisampleNV}(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_NV_framebuffer_multisample</code>   */
  private native void dispatch_glRenderbufferStorageMultisampleNV1(int target, int samples, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebufferAPPLE}(void); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  public void glResolveMultisampleFramebufferAPPLE()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glResolveMultisampleFramebufferAPPLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResolveMultisampleFramebufferAPPLE"));
    }
        dispatch_glResolveMultisampleFramebufferAPPLE1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResolveMultisampleFramebufferAPPLE}(void); </code> <br>Part of <code>GL_APPLE_framebuffer_multisample</code>   */
  private native void dispatch_glResolveMultisampleFramebufferAPPLE1(long procAddress);

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedback}(void); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  public void glResumeTransformFeedback()  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glResumeTransformFeedback;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glResumeTransformFeedback"));
    }
        dispatch_glResumeTransformFeedback1(__addr_);
  }

  /** Entry point to C language function: <code> void {@native glResumeTransformFeedback}(void); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_0</code>, <code>GL_ARB_transform_feedback2</code>   */
  private native void dispatch_glResumeTransformFeedback1(long procAddress);

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLfloat value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glSampleCoverage(float value, boolean invert)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSampleCoverage;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSampleCoverage"));
    }
        dispatch_glSampleCoverage1(value, invert, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSampleCoverage}(GLfloat value, GLboolean invert); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_3</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glSampleCoverage1(float value, boolean invert, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterf}(GLuint sampler, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public void glSamplerParameterf(int sampler, int pname, float param)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterf"));
    }
        dispatch_glSamplerParameterf1(sampler, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterf}(GLuint sampler, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  private native void dispatch_glSamplerParameterf1(int sampler, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glSamplerParameterfv(int sampler, int pname, FloatBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterfv"));
    }
        dispatch_glSamplerParameterfv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param param a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glSamplerParameterfv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameterfv}(GLuint sampler, GLenum pname, const GLfloat *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public void glSamplerParameterfv(int sampler, int pname, float[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameterfv"));
    }
        dispatch_glSamplerParameterfv1(sampler, pname, param, Buffers.SIZEOF_FLOAT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteri}(GLuint sampler, GLenum pname, GLint param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public void glSamplerParameteri(int sampler, int pname, int param)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteri"));
    }
        dispatch_glSamplerParameteri1(sampler, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteri}(GLuint sampler, GLenum pname, GLint param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  private native void dispatch_glSamplerParameteri1(int sampler, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSamplerParameteriv(int sampler, int pname, IntBuffer param)  {

    final boolean param_is_direct = Buffers.isDirect(param);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteriv"));
    }
        dispatch_glSamplerParameteriv1(sampler, pname, param_is_direct ? param : Buffers.getArray(param), param_is_direct ? Buffers.getDirectBufferByteOffset(param) : Buffers.getIndirectBufferByteOffset(param), param_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>
      @param param a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSamplerParameteriv1(int sampler, int pname, Object param, int param_byte_offset, boolean param_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSamplerParameteriv}(GLuint sampler, GLenum pname, const GLint *  param); </code> <br>Part of <code>GL_ARB_sampler_objects</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>   */
  public void glSamplerParameteriv(int sampler, int pname, int[] param, int param_offset)  {

    if(param != null && param.length <= param_offset)
      throw new GLException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSamplerParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSamplerParameteriv"));
    }
        dispatch_glSamplerParameteriv1(sampler, pname, param, Buffers.SIZEOF_INT * param_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glScissor(int x, int y, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glScissor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glScissor"));
    }
        dispatch_glScissor1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glScissor}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glScissor1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  countersList); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param countersList a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glSelectPerfMonitorCountersAMD(int monitor, boolean enable, int group, int numCounters, IntBuffer countersList)  {

    final boolean countersList_is_direct = Buffers.isDirect(countersList);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSelectPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSelectPerfMonitorCountersAMD"));
    }
        dispatch_glSelectPerfMonitorCountersAMD1(monitor, enable, group, numCounters, countersList_is_direct ? countersList : Buffers.getArray(countersList), countersList_is_direct ? Buffers.getDirectBufferByteOffset(countersList) : Buffers.getIndirectBufferByteOffset(countersList), countersList_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  countersList); </code> <br>Part of <code>GL_AMD_performance_monitor</code>
      @param countersList a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glSelectPerfMonitorCountersAMD1(int monitor, boolean enable, int group, int numCounters, Object countersList, int countersList_byte_offset, boolean countersList_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glSelectPerfMonitorCountersAMD}(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *  countersList); </code> <br>Part of <code>GL_AMD_performance_monitor</code>   */
  public void glSelectPerfMonitorCountersAMD(int monitor, boolean enable, int group, int numCounters, int[] countersList, int countersList_offset)  {

    if(countersList != null && countersList.length <= countersList_offset)
      throw new GLException("array offset argument \"countersList_offset\" (" + countersList_offset + ") equals or exceeds array length (" + countersList.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSelectPerfMonitorCountersAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSelectPerfMonitorCountersAMD"));
    }
        dispatch_glSelectPerfMonitorCountersAMD1(monitor, enable, group, numCounters, countersList, Buffers.SIZEOF_INT * countersList_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetFenceNV}(GLuint, GLenum); </code> <br>Part of <code>GL_NV_fence</code>   */
  public void glSetFenceNV(int arg0, int arg1)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glSetFenceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glSetFenceNV"));
    }
        dispatch_glSetFenceNV1(arg0, arg1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glSetFenceNV}(GLuint, GLenum); </code> <br>Part of <code>GL_NV_fence</code>   */
  private native void dispatch_glSetFenceNV1(int arg0, int arg1, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei n, const GLuint *  shaders, GLenum binaryformat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int n, IntBuffer shaders, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    final boolean shaders_is_direct = Buffers.isDirect(shaders);
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderBinary"));
    }
        dispatch_glShaderBinary1(n, shaders_is_direct ? shaders : Buffers.getArray(shaders), shaders_is_direct ? Buffers.getDirectBufferByteOffset(shaders) : Buffers.getIndirectBufferByteOffset(shaders), shaders_is_direct, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei n, const GLuint *  shaders, GLenum binaryformat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param shaders a direct or array-backed {@link java.nio.IntBuffer}
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glShaderBinary1(int n, Object shaders, int shaders_byte_offset, boolean shaders_is_direct, int binaryformat, Object binary, int binary_byte_offset, boolean binary_is_direct, int length, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderBinary}(GLsizei n, const GLuint *  shaders, GLenum binaryformat, const GLvoid *  binary, GLsizei length); </code> <br>Part of <code>GL_ARB_ES2_compatibility</code>, <code>GL_ES_VERSION_2_0</code>
      @param binary a direct or array-backed {@link java.nio.Buffer}   */
  public void glShaderBinary(int n, int[] shaders, int shaders_offset, int binaryformat, Buffer binary, int length)  {

    if ( !_context.isGLES2Compatible() ) {
    throw new GLException("Method \"glShaderBinary\" not available");
    }
    if(shaders != null && shaders.length <= shaders_offset)
      throw new GLException("array offset argument \"shaders_offset\" (" + shaders_offset + ") equals or exceeds array length (" + shaders.length + ")");
    final boolean binary_is_direct = Buffers.isDirect(binary);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderBinary;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderBinary"));
    }
        dispatch_glShaderBinary1(n, shaders, Buffers.SIZEOF_INT * shaders_offset, false, binaryformat, binary_is_direct ? binary : Buffers.getArray(binary), binary_is_direct ? Buffers.getDirectBufferByteOffset(binary) : Buffers.getIndirectBufferByteOffset(binary), binary_is_direct, length, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glShaderSource(int shader, int count, String[] string, IntBuffer length)  {

    final boolean length_is_direct = Buffers.isDirect(length);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderSource"));
    }
        dispatch_glShaderSource1(shader, count, string, length_is_direct ? length : Buffers.getArray(length), length_is_direct ? Buffers.getDirectBufferByteOffset(length) : Buffers.getIndirectBufferByteOffset(length), length_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param length a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glShaderSource1(int shader, int count, String[] string, Object length, int length_byte_offset, boolean length_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glShaderSource}(GLuint shader, GLsizei count, const GLchar * const  *  string, const GLint *  length); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glShaderSource(int shader, int count, String[] string, int[] length, int length_offset)  {

    if(length != null && length.length <= length_offset)
      throw new GLException("array offset argument \"length_offset\" (" + length_offset + ") equals or exceeds array length (" + length.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glShaderSource;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glShaderSource"));
    }
        dispatch_glShaderSource1(shader, count, string, length, Buffers.SIZEOF_INT * length_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  public void glStartTilingQCOM(int x, int y, int width, int height, int preserveMask)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStartTilingQCOM;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStartTilingQCOM"));
    }
        dispatch_glStartTilingQCOM1(x, y, width, height, preserveMask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStartTilingQCOM}(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask); </code> <br>Part of <code>GL_QCOM_tiled_rendering</code>   */
  private native void dispatch_glStartTilingQCOM1(int x, int y, int width, int height, int preserveMask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glStencilFunc(int func, int ref, int mask)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilFunc;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilFunc"));
    }
        dispatch_glStencilFunc1(func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFunc}(GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glStencilFunc1(int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glStencilFuncSeparate(int face, int func, int ref, int mask)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilFuncSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilFuncSeparate"));
    }
        dispatch_glStencilFuncSeparate1(face, func, ref, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilFuncSeparate}(GLenum face, GLenum func, GLint ref, GLuint mask); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glStencilFuncSeparate1(int face, int func, int ref, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glStencilMask(int mask)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilMask;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilMask"));
    }
        dispatch_glStencilMask1(mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMask}(GLuint mask); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glStencilMask1(int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glStencilMaskSeparate(int face, int mask)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilMaskSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilMaskSeparate"));
    }
        dispatch_glStencilMaskSeparate1(face, mask, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilMaskSeparate}(GLenum face, GLuint mask); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glStencilMaskSeparate1(int face, int mask, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glStencilOp(int fail, int zfail, int zpass)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilOp;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilOp"));
    }
        dispatch_glStencilOp1(fail, zfail, zpass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOp}(GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glStencilOp1(int fail, int zfail, int zpass, long procAddress);

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glStencilOpSeparate(int face, int fail, int zfail, int zpass)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glStencilOpSeparate;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glStencilOpSeparate"));
    }
        dispatch_glStencilOpSeparate1(face, fail, zfail, zpass, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glStencilOpSeparate}(GLenum face, GLenum fail, GLenum zfail, GLenum zpass); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glStencilOpSeparate1(int face, int fail, int zfail, int zpass, long procAddress);

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceNV}(GLuint); </code> <br>Part of <code>GL_NV_fence</code>   */
  public boolean glTestFenceNV(int arg0)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTestFenceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTestFenceNV"));
    }
        return dispatch_glTestFenceNV1(arg0, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean {@native glTestFenceNV}(GLuint); </code> <br>Part of <code>GL_NV_fence</code>   */
  private native boolean dispatch_glTestFenceNV1(int arg0, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage2D"));
    }
        dispatch_glTexImage2D1(target, level, internalformat, width, height, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage2D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glTexImage2D1(int target, int level, int internalformat, int width, int height, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , depth  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage3D"));
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>   */
  public void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexImage3D"));
    }
        dispatch_glTexImage3D1(target, level, internalformat, width, height, depth, border, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexImage3D}(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glTexImage3D1(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glTexParameterf(int target, int pname, float param)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterf;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterf"));
    }
        dispatch_glTexParameterf1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterf}(GLenum target, GLenum pname, GLfloat param); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  private native void dispatch_glTexParameterf1(int target, int pname, float param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glTexParameterfv(int target, int pname, FloatBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
    }
        dispatch_glTexParameterfv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>
      @param params a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glTexParameterfv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameterfv}(GLenum target, GLenum pname, const GLfloat *  params); </code> <br>Part of <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_ES_CM</code>   */
  public void glTexParameterfv(int target, int pname, float[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameterfv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameterfv"));
    }
        dispatch_glTexParameterfv1(target, pname, params, Buffers.SIZEOF_FLOAT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexParameteri(int target, int pname, int param)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteri;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteri"));
    }
        dispatch_glTexParameteri1(target, pname, param, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteri}(GLenum target, GLenum pname, GLint param); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glTexParameteri1(int target, int pname, int param, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glTexParameteriv(int target, int pname, IntBuffer params)  {

    final boolean params_is_direct = Buffers.isDirect(params);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
    }
        dispatch_glTexParameteriv1(target, pname, params_is_direct ? params : Buffers.getArray(params), params_is_direct ? Buffers.getDirectBufferByteOffset(params) : Buffers.getIndirectBufferByteOffset(params), params_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>
      @param params a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glTexParameteriv1(int target, int pname, Object params, int params_byte_offset, boolean params_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexParameteriv}(GLenum target, GLenum pname, const GLint *  params); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexParameteriv(int target, int pname, int[] params, int params_offset)  {

    if(params != null && params.length <= params_offset)
      throw new GLException("array offset argument \"params_offset\" (" + params_offset + ") equals or exceeds array length (" + params.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexParameteriv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexParameteriv"));
    }
        dispatch_glTexParameteriv1(target, pname, params, Buffers.SIZEOF_INT * params_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public void glTexStorage1D(int target, int levels, int internalformat, int width)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage1D"));
    }
        dispatch_glTexStorage1D1(target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage1D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_VERSION_4_2</code>, <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  private native void dispatch_glTexStorage1D1(int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_2</code>, <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public void glTexStorage2D(int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage2D"));
    }
        dispatch_glTexStorage2D1(target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage2D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_2</code>, <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  private native void dispatch_glTexStorage2D1(int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_2</code>, <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  public void glTexStorage3D(int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexStorage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexStorage3D"));
    }
        dispatch_glTexStorage3D1(target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexStorage3D}(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_4_2</code>, <code>GL_ARB_texture_storage</code>; <code>GL_EXT_texture_storage</code>   */
  private native void dispatch_glTexStorage3D1(int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , 1    , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage2D"));
    }
        dispatch_glTexSubImage2D1(target, level, xoffset, yoffset, width, height, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage2D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_1</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glTexSubImage2D1(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Buffer pixels)  {

    checkUnpackPBOUnbound(true);
    Buffers.rangeCheckBytes(pixels, imageSizeInBytes(format, type, width            , height            , depth  , false));
    final boolean pixels_is_direct = Buffers.isDirect(pixels);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage3D"));
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_is_direct ? pixels : Buffers.getArray(pixels), pixels_is_direct ? Buffers.getDirectBufferByteOffset(pixels) : Buffers.getIndirectBufferByteOffset(pixels), pixels_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>
      @param pixels a direct or array-backed {@link java.nio.Buffer}   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, Object pixels, int pixels_byte_offset, boolean pixels_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>   */
  public void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset)  {

    checkUnpackPBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTexSubImage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTexSubImage3D"));
    }
        dispatch_glTexSubImage3D1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTexSubImage3D}(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *  pixels); </code> <br>Part of <code>GL_VERSION_1_2</code>, <code>GL_ES_VERSION_3_0</code>; <code>GL_OES_texture_3D</code>   */
  private native void dispatch_glTexSubImage3D1(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, long pixels_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage1D}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage1D(int texture, int target, int levels, int internalformat, int width)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage1D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage1D"));
    }
        dispatch_glTextureStorage1D1(texture, target, levels, internalformat, width, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage1D}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  private native void dispatch_glTextureStorage1D1(int texture, int target, int levels, int internalformat, int width, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage2D}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage2D(int texture, int target, int levels, int internalformat, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage2D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage2D"));
    }
        dispatch_glTextureStorage2D1(texture, target, levels, internalformat, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage2D}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  private native void dispatch_glTextureStorage2D1(int texture, int target, int levels, int internalformat, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glTextureStorage3D}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  public void glTextureStorage3D(int texture, int target, int levels, int internalformat, int width, int height, int depth)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTextureStorage3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTextureStorage3D"));
    }
        dispatch_glTextureStorage3D1(texture, target, levels, internalformat, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTextureStorage3D}(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GL_EXT_texture_storage</code>, <code>GL_ARB_texture_storage</code>   */
  private native void dispatch_glTextureStorage3D1(int texture, int target, int levels, int internalformat, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void {@native glTransformFeedbackVaryings}(GLuint program, GLsizei count, const GLchar * const  *  varyings, GLenum bufferMode); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glTransformFeedbackVaryings(int program, int count, String[] varyings, int bufferMode)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glTransformFeedbackVaryings;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glTransformFeedbackVaryings"));
    }
        dispatch_glTransformFeedbackVaryings1(program, count, varyings, bufferMode, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glTransformFeedbackVaryings}(GLuint program, GLsizei count, const GLchar * const  *  varyings, GLenum bufferMode); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glTransformFeedbackVaryings1(int program, int count, String[] varyings, int bufferMode, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat x); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform1f(int location, float x)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1f"));
    }
        dispatch_glUniform1f1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1f}(GLint location, GLfloat x); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glUniform1f1(int location, float x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform1fv(int location, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1fv"));
    }
        dispatch_glUniform1fv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform1fv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform1fv(int location, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1fv"));
    }
        dispatch_glUniform1fv1(location, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint x); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform1i(int location, int x)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1i"));
    }
        dispatch_glUniform1i1(location, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1i}(GLint location, GLint x); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glUniform1i1(int location, int x, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1iv(int location, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1iv"));
    }
        dispatch_glUniform1iv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1iv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform1iv(int location, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1iv"));
    }
        dispatch_glUniform1iv1(location, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui}(GLint location, GLuint v0); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform1ui(int location, int v0)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1ui"));
    }
        dispatch_glUniform1ui1(location, v0, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1ui}(GLint location, GLuint v0); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  private native void dispatch_glUniform1ui1(int location, int v0, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform1uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1uiv"));
    }
        dispatch_glUniform1uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform1uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform1uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform1uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform1uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform1uiv"));
    }
        dispatch_glUniform1uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform2f(int location, float x, float y)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2f"));
    }
        dispatch_glUniform2f1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2f}(GLint location, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glUniform2f1(int location, float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform2fv(int location, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2fv"));
    }
        dispatch_glUniform2fv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform2fv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform2fv(int location, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2fv"));
    }
        dispatch_glUniform2fv1(location, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint x, GLint y); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform2i(int location, int x, int y)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2i"));
    }
        dispatch_glUniform2i1(location, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2i}(GLint location, GLint x, GLint y); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glUniform2i1(int location, int x, int y, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2iv(int location, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2iv"));
    }
        dispatch_glUniform2iv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2iv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform2iv(int location, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2iv"));
    }
        dispatch_glUniform2iv1(location, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui}(GLint location, GLuint v0, GLuint v1); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform2ui(int location, int v0, int v1)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2ui"));
    }
        dispatch_glUniform2ui1(location, v0, v1, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2ui}(GLint location, GLuint v0, GLuint v1); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  private native void dispatch_glUniform2ui1(int location, int v0, int v1, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform2uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2uiv"));
    }
        dispatch_glUniform2uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform2uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform2uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform2uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform2uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform2uiv"));
    }
        dispatch_glUniform2uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform3f(int location, float x, float y, float z)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3f"));
    }
        dispatch_glUniform3f1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3f}(GLint location, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glUniform3f1(int location, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform3fv(int location, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3fv"));
    }
        dispatch_glUniform3fv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform3fv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform3fv(int location, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3fv"));
    }
        dispatch_glUniform3fv1(location, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform3i(int location, int x, int y, int z)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3i"));
    }
        dispatch_glUniform3i1(location, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3i}(GLint location, GLint x, GLint y, GLint z); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glUniform3i1(int location, int x, int y, int z, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3iv(int location, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3iv"));
    }
        dispatch_glUniform3iv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3iv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform3iv(int location, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3iv"));
    }
        dispatch_glUniform3iv1(location, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui}(GLint location, GLuint v0, GLuint v1, GLuint v2); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform3ui(int location, int v0, int v1, int v2)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3ui"));
    }
        dispatch_glUniform3ui1(location, v0, v1, v2, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3ui}(GLint location, GLuint v0, GLuint v1, GLuint v2); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  private native void dispatch_glUniform3ui1(int location, int v0, int v1, int v2, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform3uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3uiv"));
    }
        dispatch_glUniform3uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform3uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform3uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform3uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform3uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform3uiv"));
    }
        dispatch_glUniform3uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform4f(int location, float x, float y, float z, float w)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4f"));
    }
        dispatch_glUniform4f1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4f}(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glUniform4f1(int location, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniform4fv(int location, int count, FloatBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4fv"));
    }
        dispatch_glUniform4fv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniform4fv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4fv}(GLint location, GLsizei count, const GLfloat *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform4fv(int location, int count, float[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4fv"));
    }
        dispatch_glUniform4fv1(location, count, v, Buffers.SIZEOF_FLOAT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform4i(int location, int x, int y, int z, int w)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4i"));
    }
        dispatch_glUniform4i1(location, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4i}(GLint location, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glUniform4i1(int location, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4iv(int location, int count, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4iv"));
    }
        dispatch_glUniform4iv1(location, count, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4iv1(int location, int count, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4iv}(GLint location, GLsizei count, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniform4iv(int location, int count, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4iv"));
    }
        dispatch_glUniform4iv1(location, count, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui}(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform4ui(int location, int v0, int v1, int v2, int v3)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4ui"));
    }
        dispatch_glUniform4ui1(location, v0, v1, v2, v3, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4ui}(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  private native void dispatch_glUniform4ui1(int location, int v0, int v1, int v2, int v3, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glUniform4uiv(int location, int count, IntBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4uiv"));
    }
        dispatch_glUniform4uiv1(location, count, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>
      @param value a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glUniform4uiv1(int location, int count, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniform4uiv}(GLint location, GLsizei count, const GLuint *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>; <code>GL_EXT_gpu_shader4</code>   */
  public void glUniform4uiv(int location, int count, int[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniform4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniform4uiv"));
    }
        dispatch_glUniform4uiv1(location, count, value, Buffers.SIZEOF_INT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBlockBinding}(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>   */
  public void glUniformBlockBinding(int program, int uniformBlockIndex, int uniformBlockBinding)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformBlockBinding;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformBlockBinding"));
    }
        dispatch_glUniformBlockBinding1(program, uniformBlockIndex, uniformBlockBinding, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformBlockBinding}(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_ARB_uniform_buffer_object</code>, <code>GL_VERSION_3_1</code>   */
  private native void dispatch_glUniformBlockBinding1(int program, int uniformBlockIndex, int uniformBlockBinding, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fv"));
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniformMatrix2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2fv"));
    }
        dispatch_glUniformMatrix2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fv"));
    }
        dispatch_glUniformMatrix2x3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix2x3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x3fv"));
    }
        dispatch_glUniformMatrix2x3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix2x4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fv"));
    }
        dispatch_glUniformMatrix2x4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix2x4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix2x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix2x4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix2x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix2x4fv"));
    }
        dispatch_glUniformMatrix2x4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fv"));
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniformMatrix3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3fv"));
    }
        dispatch_glUniformMatrix3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fv"));
    }
        dispatch_glUniformMatrix3x2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix3x2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x2fv"));
    }
        dispatch_glUniformMatrix3x2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix3x4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fv"));
    }
        dispatch_glUniformMatrix3x4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix3x4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix3x4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix3x4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix3x4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix3x4fv"));
    }
        dispatch_glUniformMatrix3x4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fv"));
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUniformMatrix4fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4fv"));
    }
        dispatch_glUniformMatrix4fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x2fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fv"));
    }
        dispatch_glUniformMatrix4x2fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x2fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x2fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix4x2fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x2fv"));
    }
        dispatch_glUniformMatrix4x2fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glUniformMatrix4x3fv(int location, int count, boolean transpose, FloatBuffer value)  {

    final boolean value_is_direct = Buffers.isDirect(value);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fv"));
    }
        dispatch_glUniformMatrix4x3fv1(location, count, transpose, value_is_direct ? value : Buffers.getArray(value), value_is_direct ? Buffers.getDirectBufferByteOffset(value) : Buffers.getIndirectBufferByteOffset(value), value_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>
      @param value a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glUniformMatrix4x3fv1(int location, int count, boolean transpose, Object value, int value_byte_offset, boolean value_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glUniformMatrix4x3fv}(GLint location, GLsizei count, GLboolean transpose, const GLfloat *  value); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_2_1</code>   */
  public void glUniformMatrix4x3fv(int location, int count, boolean transpose, float[] value, int value_offset)  {

    if(value != null && value.length <= value_offset)
      throw new GLException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUniformMatrix4x3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUniformMatrix4x3fv"));
    }
        dispatch_glUniformMatrix4x3fv1(location, count, transpose, value, Buffers.SIZEOF_FLOAT * value_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glUseProgram(int program)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUseProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glUseProgram"));
    }
        dispatch_glUseProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glUseProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glUseProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glValidateProgram(int program)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glValidateProgram;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glValidateProgram"));
    }
        dispatch_glValidateProgram1(program, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glValidateProgram}(GLuint program); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glValidateProgram1(int program, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint indx, GLfloat x); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib1f(int indx, float x)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1f"));
    }
        dispatch_glVertexAttrib1f1(indx, x, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1f}(GLuint indx, GLfloat x); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glVertexAttrib1f1(int indx, float x, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib1fv(int indx, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fv"));
    }
        dispatch_glVertexAttrib1fv1(indx, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib1fv1(int indx, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib1fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib1fv(int indx, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib1fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib1fv"));
    }
        dispatch_glVertexAttrib1fv1(indx, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint indx, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib2f(int indx, float x, float y)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2f"));
    }
        dispatch_glVertexAttrib2f1(indx, x, y, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2f}(GLuint indx, GLfloat x, GLfloat y); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glVertexAttrib2f1(int indx, float x, float y, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib2fv(int indx, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fv"));
    }
        dispatch_glVertexAttrib2fv1(indx, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib2fv1(int indx, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib2fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib2fv(int indx, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib2fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib2fv"));
    }
        dispatch_glVertexAttrib2fv1(indx, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint indx, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib3f(int indx, float x, float y, float z)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3f"));
    }
        dispatch_glVertexAttrib3f1(indx, x, y, z, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3f}(GLuint indx, GLfloat x, GLfloat y, GLfloat z); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glVertexAttrib3f1(int indx, float x, float y, float z, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib3fv(int indx, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fv"));
    }
        dispatch_glVertexAttrib3fv1(indx, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib3fv1(int indx, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib3fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib3fv(int indx, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib3fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib3fv"));
    }
        dispatch_glVertexAttrib3fv1(indx, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4f(int indx, float x, float y, float z, float w)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4f;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4f"));
    }
        dispatch_glVertexAttrib4f1(indx, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4f}(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glVertexAttrib4f1(int indx, float x, float y, float z, float w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  public void glVertexAttrib4fv(int indx, FloatBuffer values)  {

    final boolean values_is_direct = Buffers.isDirect(values);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fv"));
    }
        dispatch_glVertexAttrib4fv1(indx, values_is_direct ? values : Buffers.getArray(values), values_is_direct ? Buffers.getDirectBufferByteOffset(values) : Buffers.getIndirectBufferByteOffset(values), values_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param values a direct or array-backed {@link java.nio.FloatBuffer}   */
  private native void dispatch_glVertexAttrib4fv1(int indx, Object values, int values_byte_offset, boolean values_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttrib4fv}(GLuint indx, const GLfloat *  values); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glVertexAttrib4fv(int indx, float[] values, int values_offset)  {

    if(values != null && values.length <= values_offset)
      throw new GLException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttrib4fv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttrib4fv"));
    }
        dispatch_glVertexAttrib4fv1(indx, values, Buffers.SIZEOF_FLOAT * values_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisor}(GLuint index, GLuint divisor); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>; <code>GL_ARB_instanced_arrays</code>   */
  public void glVertexAttribDivisor(int index, int divisor)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribDivisor;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribDivisor"));
    }
        dispatch_glVertexAttribDivisor1(index, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisor}(GLuint index, GLuint divisor); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_3</code>; <code>GL_ARB_instanced_arrays</code>   */
  private native void dispatch_glVertexAttribDivisor1(int index, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisorANGLE}(GLuint index, GLuint divisor); </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code>   */
  public void glVertexAttribDivisorANGLE(int index, int divisor)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribDivisorANGLE;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribDivisorANGLE"));
    }
        dispatch_glVertexAttribDivisorANGLE1(index, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisorANGLE}(GLuint index, GLuint divisor); </code> <br>Part of <code>GL_ANGLE_instanced_arrays</code>   */
  private native void dispatch_glVertexAttribDivisorANGLE1(int index, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisorNV}(GLuint index, GLuint divisor); </code> <br>Part of <code>GL_NV_instanced_arrays</code>   */
  public void glVertexAttribDivisorNV(int index, int divisor)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribDivisorNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribDivisorNV"));
    }
        dispatch_glVertexAttribDivisorNV1(index, divisor, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribDivisorNV}(GLuint index, GLuint divisor); </code> <br>Part of <code>GL_NV_instanced_arrays</code>   */
  private native void dispatch_glVertexAttribDivisorNV1(int index, int divisor, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4i}(GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4i(int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4i;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4i"));
    }
        dispatch_glVertexAttribI4i1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4i}(GLuint index, GLint x, GLint y, GLint z, GLint w); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glVertexAttribI4i1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4iv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iv"));
    }
        dispatch_glVertexAttribI4iv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4iv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4iv}(GLuint index, const GLint *  v); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4iv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4iv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4iv"));
    }
        dispatch_glVertexAttribI4iv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ui}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4ui(int index, int x, int y, int z, int w)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4ui;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4ui"));
    }
        dispatch_glVertexAttribI4ui1(index, x, y, z, w, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4ui}(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glVertexAttribI4ui1(int index, int x, int y, int z, int w, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  public void glVertexAttribI4uiv(int index, IntBuffer v)  {

    final boolean v_is_direct = Buffers.isDirect(v);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiv"));
    }
        dispatch_glVertexAttribI4uiv1(index, v_is_direct ? v : Buffers.getArray(v), v_is_direct ? Buffers.getDirectBufferByteOffset(v) : Buffers.getIndirectBufferByteOffset(v), v_is_direct, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param v a direct or array-backed {@link java.nio.IntBuffer}   */
  private native void dispatch_glVertexAttribI4uiv1(int index, Object v, int v_byte_offset, boolean v_is_direct, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribI4uiv}(GLuint index, const GLuint *  v); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribI4uiv(int index, int[] v, int v_offset)  {

    if(v != null && v.length <= v_offset)
      throw new GLException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribI4uiv;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribI4uiv"));
    }
        dispatch_glVertexAttribI4uiv1(index, v, Buffers.SIZEOF_INT * v_offset, false, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glVertexAttribIPointer(int index, int size, int type, int stride, Buffer pointer)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(pointer, 1);
    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribIPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointer"));
    }
        dispatch_glVertexAttribIPointer0(index, size, type, stride, pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribIPointer0(int index, int size, int type, int stride, Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  public void glVertexAttribIPointer(int index, int size, int type, int stride, long pointer_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribIPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribIPointer"));
    }
        dispatch_glVertexAttribIPointer0(index, size, type, stride, pointer_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribIPointer}(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *  pointer); </code> <br>Part of <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_0</code>   */
  private native void dispatch_glVertexAttribIPointer0(int index, int size, int type, int stride, long pointer_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  public void glVertexAttribPointer(int indx, int size, int type, boolean normalized, int stride, Buffer ptr)  {

    checkArrayVBOUnbound(true);
    Buffers.rangeCheck(ptr, 1);
    if (!Buffers.isDirect(ptr))
      throw new GLException("Argument \"ptr\" is not a direct buffer");
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointer"));
    }
        dispatch_glVertexAttribPointer0(indx, size, type, normalized, stride, ptr, Buffers.getDirectBufferByteOffset(ptr), __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>
      @param ptr a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glVertexAttribPointer0(int indx, int size, int type, boolean normalized, int stride, Object ptr, int ptr_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  public void glVertexAttribPointer(int indx, int size, int type, boolean normalized, int stride, long ptr_buffer_offset)  {

    checkArrayVBOBound(true);
    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glVertexAttribPointer;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glVertexAttribPointer"));
    }
        dispatch_glVertexAttribPointer0(indx, size, type, normalized, stride, ptr_buffer_offset, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glVertexAttribPointer}(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *  ptr); </code> <br>Part of <code>GL_ES_VERSION_2_0</code>, <code>GL_VERSION_2_0</code>   */
  private native void dispatch_glVertexAttribPointer0(int indx, int size, int type, boolean normalized, int stride, long ptr_buffer_offset, long procAddress);

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  public void glViewport(int x, int y, int width, int height)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glViewport;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glViewport"));
    }
        dispatch_glViewport1(x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glViewport}(GLint x, GLint y, GLsizei width, GLsizei height); </code> <br>Part of <code>GL_VERSION_ES_CL_CM</code>, <code>GL_VERSION_1_0</code>, <code>GL_ES_VERSION_2_0</code>   */
  private native void dispatch_glViewport1(int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> void {@native glWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  public void glWaitSync(long sync, int flags, long timeout)  {

    final long __addr_ = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glWaitSync;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glWaitSync"));
    }
        dispatch_glWaitSync1(sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> void {@native glWaitSync}(GLsync sync, GLbitfield flags, GLuint64 timeout); </code> <br>Part of <code>GL_ARB_sync</code>, <code>GL_ES_VERSION_3_0</code>, <code>GL_VERSION_3_2</code>   */
  private native void dispatch_glWaitSync1(long sync, int flags, long timeout, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static final int params_offset = 0; // just a helper for JavaPrologue ..
      @Override
      public GLProfile getGLProfile() {
          return this.glProfile;
      }
      private final GLProfile glProfile;
  
      @Override
      public final int glGetBoundBuffer(int target) {
          return getBoundBuffer(target);
      }
      @Override
      public final int getBoundBuffer(int target) {
          return bufferStateTracker.getBoundBufferObject(target, this);
      }
  
      @Override
      public final long glGetBufferSize(int bufferName) {
          return bufferObjectTracker.getBufferSize(bufferName);
      }
      @Override
      public final GLBufferStorage getBufferStorage(int bufferName) {
          return bufferObjectTracker.getBufferStorage(bufferName);
      }
  
      @Override
      public final boolean glIsVBOArrayBound() {
          return isVBOArrayBound();
      }
      @Override
      public final boolean isVBOArrayBound() {
          return checkArrayVBOBound(false);
      }
  
      @Override
      public final boolean glIsVBOElementArrayBound() {
          return isVBOElementArrayBound();
      }
      @Override
      public final boolean isVBOElementArrayBound() {
          return checkElementVBOBound(false);
      }
  
      @Override
      public final GL getDownstreamGL() throws GLException {
          return null;
      }
  
      @Override
      public final GL getRootGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isGL() {
          return true;
      }
        
      @Override
      public final GL getGL() throws GLException {
          return this;
      }
  
      @Override
      public final boolean isFunctionAvailable(String glFunctionName) {
        return _context.isFunctionAvailable(glFunctionName);
      }
  
      @Override
      public final boolean isExtensionAvailable(String glExtensionName) {
        return _context.isExtensionAvailable(glExtensionName);
      }
  
      @Override
      public final Object getExtension(String extensionName) {
        // At this point we don't expose any extensions using this mechanism
        return null;
      }
  
      @Override
      public final boolean hasBasicFBOSupport() {
        return _context.hasBasicFBOSupport();
      }
  
      @Override
      public final boolean hasFullFBOSupport() {
        return _context.hasFullFBOSupport();
      }
  
      @Override
      public final int getMaxRenderbufferSamples() {
        return _context.getMaxRenderbufferSamples();
      }
  
      @Override
      public final boolean isTextureFormatBGRA8888Available() {
        return _context.isTextureFormatBGRA8888Available();
      }
  
      @Override
      public final GLContext getContext() {
        return _context;
      }
  
      private final GLContextImpl _context;
  
      /**
       * @see javax.media.opengl.GLContext#setSwapInterval(int)
       */
      @Override
      public final void setSwapInterval(int interval) {
        _context.setSwapInterval(interval);
      }
  
      /**
       * @see javax.media.opengl.GLContext#getSwapInterval()
       */
      @Override
      public final int getSwapInterval() {
        return _context.getSwapInterval();
      }
  
      @Override
      public final Object getPlatformGLExtensions() {
        return _context.getPlatformGLExtensions();
      }
  
      @Override
      public final int getBoundFramebuffer(int target) {
        return _context.getBoundFramebuffer(target);
      }
  
      @Override
      public final int getDefaultDrawFramebuffer() {
        return _context.getDefaultDrawFramebuffer();
      }
  
      @Override
      public final int getDefaultReadFramebuffer() {
        return _context.getDefaultReadFramebuffer();
      }
  
      @Override
      public final int getDefaultReadBuffer() {
        return _context.getDefaultReadBuffer();
      }
  
      private final GLStateTracker       glStateTracker;
  
      //
      // GLBufferObjectTracker Redirects
      //
      private final GLBufferObjectTracker bufferObjectTracker;
      private final GLBufferStateTracker bufferStateTracker;
  
      private final jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch createBoundMutableStorageDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.CreateStorageDispatch() {
              public final void create(final int target, final long size, final Buffer data, final int mutableUsage, final long glProcAddress) {
                  final boolean data_is_direct = Buffers.isDirect(data);
                  dispatch_glBufferData(target, size, 
                                        data_is_direct ? data : Buffers.getArray(data), 
                                        data_is_direct ? Buffers.getDirectBufferByteOffset(data) : Buffers.getIndirectBufferByteOffset(data), 
                                        data_is_direct, mutableUsage, glProcAddress);
              }
          };
      private native void dispatch_glBufferData(int target, long size, Object data, int data_byte_offset, boolean data_is_direct, int usage, long procAddress);
  
      private final jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch unmapBoundBufferDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.UnmapBufferDispatch() {
              public final boolean unmap(final int target, final long glProcAddress) {
                  return dispatch_glUnmapBuffer(target, glProcAddress);
              }
          };
      private native boolean dispatch_glUnmapBuffer(int target, long procAddress);
  
      @Override
      public final java.nio.ByteBuffer glMapBuffer(int target, int access) {
        return mapBuffer(target, access).getMappedBuffer();
      }
  
      @Override
      public final ByteBuffer glMapBufferRange(int target, long offset, long length, int access)  {
        return mapBufferRange(target, offset, length, access).getMappedBuffer();
      }
  
      private final jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch mapBoundBufferAllDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.MapBufferAllDispatch() {
              public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
              public final long mapBuffer(final int target, final int access, final long glProcAddress) {
                  return dispatch_glMapBuffer(target, access, glProcAddress);
              }
          };
      private native long dispatch_glMapBuffer(int target, int access, long glProcAddress);
  
      private final jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch mapBoundBufferRangeDispatch = 
          new jogamp.opengl.GLBufferObjectTracker.MapBufferRangeDispatch() {
              public final ByteBuffer allocNioByteBuffer(final long addr, final long length) { return newDirectByteBuffer(addr, length); }
              public final long mapBuffer(final int target, final long offset, final long length, final int access, final long glProcAddress) {
                  return dispatch_glMapBufferRange(target, offset, length, access, glProcAddress);
              }
          };
      private native long dispatch_glMapBufferRange(int target, long offset, long length, int access, long glProcAddress);
  
      private native ByteBuffer newDirectByteBuffer(long addr, long capacity);
  
  public GLES3Impl(GLProfile glp, GLContextImpl context) {
    this._context = context; 
    if(null != context) {
        this.bufferObjectTracker  = context.getBufferObjectTracker();
        this.bufferStateTracker = context.getBufferStateTracker();
        this.glStateTracker     = context.getGLStateTracker();
    } else {
        this.bufferObjectTracker  = null;
        this.bufferStateTracker = null;
        this.glStateTracker     = null;
    }
    this.glProfile = glp;
    this._isES3 = glp.getImplName() == GLProfile.GLES3;
  }
  
  public final void finalizeInit() {
  }
  
  @Override
  public final boolean isGL4bc() {
      return false;
  }
  
  @Override
  public final boolean isGL4() {
      return false;
  }
  
  @Override
  public final boolean isGL3bc() {
      return false;
  }
  
  @Override
  public final boolean isGL3() {
      return false;
  }
  
  public final boolean isGL2() {
      return false;
  }
  
  @Override
  public final boolean isGLES1() {
      return false;
  }
  
  @Override
  public final boolean isGLES2() {
      return true;
  }
  
  @Override
  public final boolean isGLES3() {
      return _isES3;
  }
  
  @Override
  public final boolean isGLES() {
      return true;
  }
  
  @Override
  public final boolean isGL2ES1() {
      return false;
  }
  
  @Override
  public final boolean isGL2ES2() {
      return true;
  }
  
  @Override
  public final boolean isGL2ES3() {
      return _isES3;
  }
  
  @Override
  public final boolean isGL3ES3() {
      return _isES3;
  }
  
  @Override
  public final boolean isGL4ES3() {
      return _isES3;
  }
  
  @Override
  public final boolean isGL4core() {
      return false;
  }
  
  @Override
  public final boolean isGL3core() {
      return false;
  }
  
  @Override
  public final boolean isGLcore() {
      return true;
  }
  
  @Override
  public final boolean isGLES2Compatible() {
      return true;
  }
  
  @Override
  public final boolean isGLES3Compatible() {
      return _isES3;
  }
  
  
  @Override
  public final boolean isGL2GL3() {
      return false;
  }
  
  @Override
  public final boolean hasGLSL() {
      return true;
  }
  
  @Override
  public boolean isNPOTTextureAvailable() {
    return true;
  }
  
  @Override
  public final GL4bc getGL4bc() throws GLException {
      throw new GLException("Not a GL4bc implementation");
  }
  
  @Override
  public final GL4 getGL4() throws GLException {
      throw new GLException("Not a GL4 implementation");
  }
  
  @Override
  public final GL3bc getGL3bc() throws GLException {
      throw new GLException("Not a GL3bc implementation");
  }
  
  @Override
  public final GL3 getGL3() throws GLException {
      throw new GLException("Not a GL3 implementation");
  }
  
  @Override
  public final GL2 getGL2() throws GLException {
      throw new GLException("Not a GL2 implementation");
  }
  
  @Override
  public final GLES1 getGLES1() throws GLException {
      throw new GLException("Not a GLES1 implementation");
  }
  
  @Override
  public final GLES2 getGLES2() throws GLException {
      return this;
  }
  
  @Override
  public final GLES3 getGLES3() throws GLException {
      return this;
  }
  
  @Override
  public final GL2ES1 getGL2ES1() throws GLException {
      throw new GLException("Not a GL2ES1 implementation");
  }
  
  @Override
  public final GL2ES2 getGL2ES2() throws GLException {
      return this;
  }
  
  @Override
  public final GL2ES3 getGL2ES3() throws GLException {
      if(!_isES3) {
          throw new GLException("Not a GL2ES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL3ES3 getGL3ES3() throws GLException {
      if(!_isES3) {
          throw new GLException("Not a GL3ES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL4ES3 getGL4ES3() throws GLException {
      if(!_isES3) {
          throw new GLException("Not a GL4ES3 implementation");
      }
      return this;
  }
  
  @Override
  public final GL2GL3 getGL2GL3() throws GLException {
      throw new GLException("Not a GL2GL3 implementation");
  }
  
  //
  // Helpers for ensuring the correct amount of texture data
  //
  
  private final boolean _isES3;
  
  private final boolean checkBufferObject(boolean extensionAvail,
                                          boolean allowVAO,
                                          boolean bound,
                                          int state,
                                          String kind, boolean throwException) {
    if ( !extensionAvail ) {
      if ( !bound ) {
        return true;
      }
      if(throwException) {
          throw new GLException("Required extensions not available to call this function");
      }
      return false;
    }
    int buffer = bufferStateTracker.getBoundBufferObject(state, this);
    if ( bound ) {
      if ( 0 != buffer ) {
          return true;
      }
      if ( allowVAO ) {
          buffer = bufferStateTracker.getBoundBufferObject(GL2ES3.GL_VERTEX_ARRAY_BINDING, this);
          if( 0 != buffer && _context.getDefaultVAO() != buffer ) {
              return true;
          }
      }
      if ( throwException ) {
          throw new GLException(kind + " must be bound to call this method");
      }
      return false;
    } else {
      if ( 0 == buffer ) {
          return true;
      }
      if ( throwException ) {
          throw new GLException(kind + " must be unbound to call this method");
      }
      return false;
    }
  }  
  
  private final void validateCPUSourcedAvail() {
      if(!_context.isCPUDataSourcingAvail()) {
          throw new GLException("CPU data sourcing n/a w/ "+_context);
      }
  }
  
  private final boolean checkArrayVBOUnbound(boolean throwException) { 
    if(throwException) {
        validateCPUSourcedAvail();
    }
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             false, // bound
                             GL.GL_ARRAY_BUFFER,
                             "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkArrayVBOBound(boolean throwException) { 
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             true, // bound
                             GL.GL_ARRAY_BUFFER,
                             "array vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOUnbound(boolean throwException) { 
    if(throwException) {
        validateCPUSourcedAvail();
    }
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             false, // bound
                             GL.GL_ELEMENT_ARRAY_BUFFER,
                             "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkElementVBOBound(boolean throwException) { 
    return checkBufferObject(true,
                             _isES3, // allowVAO
                             true, // bound
                             GL.GL_ELEMENT_ARRAY_BUFFER,
                             "element vertex_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBOUnbound(boolean throwException) { 
    return checkBufferObject(_isES3,
                             false, // allowVAO
                             false, // bound
                             GL2.GL_PIXEL_UNPACK_BUFFER,
                             "unpack pixel_buffer_object", throwException);
  }
  
  private final boolean checkUnpackPBOBound(boolean throwException) { 
    return checkBufferObject(_isES3,
                             false, // allowVAO
                             true, // bound
                             GL2.GL_PIXEL_UNPACK_BUFFER,
                             "unpack pixel_buffer_object", throwException);
  }
  
  private final boolean checkPackPBOUnbound(boolean throwException) { 
    return checkBufferObject(_isES3,
                             false, // allowVAO
                             false, // bound
                             GL2.GL_PIXEL_PACK_BUFFER,
                             "pack pixel_buffer_object", throwException);
  }
  
  private final boolean checkPackPBOBound(boolean throwException) { 
    return checkBufferObject(_isES3,
                             false, // allowVAO
                             true, // bound
                             GL2.GL_PIXEL_PACK_BUFFER,
                             "pack pixel_buffer_object", throwException);
  }
  
  @Override
  public final boolean glIsPBOPackBound() {
      return isPBOPackBound();
  }
  @Override
  public final boolean isPBOPackBound() {
      return checkPackPBOBound(false);
  }
  
  @Override
  public final boolean glIsPBOUnpackBound() {
      return isPBOUnpackBound();
  }
  @Override
  public final boolean isPBOUnpackBound() {
      return checkUnpackPBOBound(false);
  }
  
  @Override
  public final void glClearDepth(double depth) {
      glClearDepthf((float)depth); 
  }
  
  @Override
  public final void glDepthRange(double zNear, double zFar) {
      glDepthRangef((float)zNear, (float)zFar); 
  }
  
  //
  // GLBufferObjectTracker Redirects
  //
  
  @Override
  public final void glBufferData(int target, long size, Buffer data, int usage)  {
      final long glProcAddress = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glBufferData;
      if ( 0 == glProcAddress ) {
        throw new GLException(String.format("Method \"%s\" not available", "glBufferData"));
      }
      bufferObjectTracker.createBufferStorage(bufferStateTracker, this, 
                                              target, size, data, usage, 0 /* immutableFlags */,
                                              createBoundMutableStorageDispatch, glProcAddress);
  }
  
  @Override
  public boolean glUnmapBuffer(int target)  {
      final long glProcAddress = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glUnmapBuffer;
      if ( 0 == glProcAddress ) {
        throw new GLException(String.format("Method \"%s\" not available", "glUnmapBuffer"));
      }
      return bufferObjectTracker.unmapBuffer(bufferStateTracker, this, target, unmapBoundBufferDispatch, glProcAddress);
  }
  
  @Override
  public final GLBufferStorage mapBuffer(final int target, final int access) {
    final long glProcAddress = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapBuffer;
    if ( 0 == glProcAddress ) {
      throw new GLException("Method \"glMapBuffer\" not available");
    }
    return bufferObjectTracker.mapBuffer(bufferStateTracker, this, target, access, mapBoundBufferAllDispatch, glProcAddress);
  }
  @Override
  public final GLBufferStorage mapBufferRange(final int target, final long offset, final long length, final int access) {
    final long glProcAddress = ((GLES3ProcAddressTable)_context.getGLProcAddressTable())._addressof_glMapBufferRange;
    if ( 0 == glProcAddress ) {
      throw new GLException("Method \"glMapBufferRange\" not available");
    }
    return bufferObjectTracker.mapBuffer(bufferStateTracker, this, target, offset, length, access, mapBoundBufferRangeDispatch, glProcAddress);
  }
  
  
  
      private int[] imageSizeTemp = new int[1];
  
      private final int imageSizeInBytes(int format, int type, int width, int height, int depth, boolean pack) {
          return GLBuffers.sizeof(this, imageSizeTemp, format, type, width, height, depth, pack) ;                                    
      }
  
    @Override
    public final void glVertexAttribPointer(GLArrayData array) {
      if(array.getComponentCount()==0) return;
      if(array.isVBO()) {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getVBOOffset());
      } else {
          glVertexAttribPointer(array.getLocation(), array.getComponentCount(), array.getComponentType(), 
                                array.getNormalized(), array.getStride(), array.getBuffer());
      }
    }
  
    @Override
    public final void glUniform(GLUniformData data) {
      boolean done=false;
      if(data.isBuffer()) {
          Buffer buffer = data.getBuffer();
          if(data.isMatrix()) {
              if(buffer instanceof FloatBuffer) {
                  switch(data.columns()) {
                      case 2: glUniformMatrix2fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 3: glUniformMatrix3fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                      case 4: glUniformMatrix4fv(data.getLocation(), data.count(), false, (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniformMatrix only available for 2fv, 3fv and 4fv");
              }
          } else {
              if(buffer instanceof IntBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 2: glUniform2iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 3: glUniform3iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                      case 4: glUniform4iv(data.getLocation(), data.count(), (IntBuffer)buffer); done=true; break;
                  }
              } else if(buffer instanceof FloatBuffer) {
                  switch(data.components()) {
                      case 1: glUniform1fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 2: glUniform2fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 3: glUniform3fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                      case 4: glUniform4fv(data.getLocation(), data.count(), (FloatBuffer)buffer); done=true; break;
                  }
              }
              if(!done) {
                  throw new GLException("glUniform vector only available for 1[if]v 2[if]v, 3[if]v and 4[if]v");
              }
          }
      } else {
          Object obj = data.getObject();
          if(obj instanceof Integer) {
              glUniform1i(data.getLocation(), ((Integer)obj).intValue());
              done=true;
          } else if (obj instanceof Float) {
              glUniform1f(data.getLocation(), ((Float)obj).floatValue());
              done=true;
          }
          if(!done) {
              throw new GLException("glUniform atom only available for 1i and 1f");
          }
      }
    }
  
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLES3Impl
