/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Tue Mar 11 04:19:28 CET 2014 ----! */

package jogamp.opengl.windows.wgl;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class WGLExtImpl implements WGLExt{
  /** Entry point to C language function: <code> LPVOID wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>   */
  public ByteBuffer wglAllocateMemoryNV(int size, float readfreq, float writefreq, float priority)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglAllocateMemoryNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglAllocateMemoryNV"));
    }
    final ByteBuffer _res;
    _res = dispatch_wglAllocateMemoryNV0(size, readfreq, writefreq, priority, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> LPVOID wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>   */
  private native ByteBuffer dispatch_wglAllocateMemoryNV0(int size, float readfreq, float writefreq, float priority, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBeginFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public boolean wglBeginFrameTrackingI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBeginFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBeginFrameTrackingI3D"));
    }
        return dispatch_wglBeginFrameTrackingI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBeginFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  private native boolean dispatch_wglBeginFrameTrackingI3D0(long procAddress);

  /** Entry point to C language function: <code> GLboolean wglBindDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public boolean wglBindDisplayColorTableEXT(short id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBindDisplayColorTableEXT"));
    }
        return dispatch_wglBindDisplayColorTableEXT0(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglBindDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  private native boolean dispatch_wglBindDisplayColorTableEXT0(short id, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindSwapBarrierNV(GLuint group, GLuint barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglBindSwapBarrierNV(int group, int barrier)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindSwapBarrierNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBindSwapBarrierNV"));
    }
        return dispatch_wglBindSwapBarrierNV0(group, barrier, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindSwapBarrierNV(GLuint group, GLuint barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  private native boolean dispatch_wglBindSwapBarrierNV0(int group, int barrier, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindTexImageARB(HANDLE hPbuffer, int iBuffer); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public boolean wglBindTexImageARB(long hPbuffer, int iBuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindTexImageARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBindTexImageARB"));
    }
        return dispatch_wglBindTexImageARB0(hPbuffer, iBuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindTexImageARB(HANDLE hPbuffer, int iBuffer); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  private native boolean dispatch_wglBindTexImageARB0(long hPbuffer, int iBuffer, long procAddress);

  /** Entry point to C language function: <code> void wglBlitContextFramebufferAMD(HANDLE dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  public void wglBlitContextFramebufferAMD(long dstCtx, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBlitContextFramebufferAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglBlitContextFramebufferAMD"));
    }
        dispatch_wglBlitContextFramebufferAMD0(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter, __addr_);
  }

  /** Entry point to C language function: <code> void wglBlitContextFramebufferAMD(HANDLE dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  private native void dispatch_wglBlitContextFramebufferAMD0(long dstCtx, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter, long procAddress);

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatARB(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttribIList a direct only {@link java.nio.IntBuffer}
      @param pfAttribFList a direct only {@link java.nio.FloatBuffer}
      @param piFormats a direct only {@link java.nio.IntBuffer}
      @param nNumFormats a direct only {@link java.nio.IntBuffer}   */
  public boolean wglChoosePixelFormatARB(long hdc, IntBuffer piAttribIList, FloatBuffer pfAttribFList, int nMaxFormats, IntBuffer piFormats, IntBuffer nNumFormats)  {

    if (!Buffers.isDirect(piAttribIList))
      throw new GLException("Argument \"piAttribIList\" is not a direct buffer");
    if (!Buffers.isDirect(pfAttribFList))
      throw new GLException("Argument \"pfAttribFList\" is not a direct buffer");
    if (!Buffers.isDirect(piFormats))
      throw new GLException("Argument \"piFormats\" is not a direct buffer");
    if (!Buffers.isDirect(nNumFormats))
      throw new GLException("Argument \"nNumFormats\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglChoosePixelFormatARB"));
    }
        return dispatch_wglChoosePixelFormatARB0(hdc, piAttribIList, Buffers.getDirectBufferByteOffset(piAttribIList), pfAttribFList, Buffers.getDirectBufferByteOffset(pfAttribFList), nMaxFormats, piFormats, Buffers.getDirectBufferByteOffset(piFormats), nNumFormats, Buffers.getDirectBufferByteOffset(nNumFormats), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatARB(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttribIList a direct only {@link java.nio.IntBuffer}
      @param pfAttribFList a direct only {@link java.nio.FloatBuffer}
      @param piFormats a direct only {@link java.nio.IntBuffer}
      @param nNumFormats a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglChoosePixelFormatARB0(long hdc, Object piAttribIList, int piAttribIList_byte_offset, Object pfAttribFList, int pfAttribFList_byte_offset, int nMaxFormats, Object piFormats, int piFormats_byte_offset, Object nNumFormats, int nNumFormats_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatEXT(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttribIList a direct only {@link java.nio.IntBuffer}
      @param pfAttribFList a direct only {@link java.nio.FloatBuffer}
      @param piFormats a direct only {@link java.nio.IntBuffer}
      @param nNumFormats a direct only {@link java.nio.IntBuffer}   */
  public boolean wglChoosePixelFormatEXT(long hdc, IntBuffer piAttribIList, FloatBuffer pfAttribFList, int nMaxFormats, IntBuffer piFormats, IntBuffer nNumFormats)  {

    if (!Buffers.isDirect(piAttribIList))
      throw new GLException("Argument \"piAttribIList\" is not a direct buffer");
    if (!Buffers.isDirect(pfAttribFList))
      throw new GLException("Argument \"pfAttribFList\" is not a direct buffer");
    if (!Buffers.isDirect(piFormats))
      throw new GLException("Argument \"piFormats\" is not a direct buffer");
    if (!Buffers.isDirect(nNumFormats))
      throw new GLException("Argument \"nNumFormats\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglChoosePixelFormatEXT"));
    }
        return dispatch_wglChoosePixelFormatEXT0(hdc, piAttribIList, Buffers.getDirectBufferByteOffset(piAttribIList), pfAttribFList, Buffers.getDirectBufferByteOffset(pfAttribFList), nMaxFormats, piFormats, Buffers.getDirectBufferByteOffset(piFormats), nNumFormats, Buffers.getDirectBufferByteOffset(nNumFormats), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatEXT(HANDLE hdc, const int *  piAttribIList, const FLOAT *  pfAttribFList, UINT nMaxFormats, int *  piFormats, UINT *  nNumFormats); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttribIList a direct only {@link java.nio.IntBuffer}
      @param pfAttribFList a direct only {@link java.nio.FloatBuffer}
      @param piFormats a direct only {@link java.nio.IntBuffer}
      @param nNumFormats a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglChoosePixelFormatEXT0(long hdc, Object piAttribIList, int piAttribIList_byte_offset, Object pfAttribFList, int pfAttribFList_byte_offset, int nMaxFormats, Object piFormats, int piFormats_byte_offset, Object nNumFormats, int nNumFormats_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglCopyImageSubDataNV(HANDLE hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HANDLE hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>WGL_NV_copy_image</code>   */
  public boolean wglCopyImageSubDataNV(long hSrcRC, int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, long hDstRC, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCopyImageSubDataNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCopyImageSubDataNV"));
    }
        return dispatch_wglCopyImageSubDataNV0(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglCopyImageSubDataNV(HANDLE hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HANDLE hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>WGL_NV_copy_image</code>   */
  private native boolean dispatch_wglCopyImageSubDataNV0(long hSrcRC, int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, long hDstRC, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreateAssociatedContextAMD(UINT id); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  public long wglCreateAssociatedContextAMD(int id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateAssociatedContextAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateAssociatedContextAMD"));
    }
        return dispatch_wglCreateAssociatedContextAMD0(id, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateAssociatedContextAMD(UINT id); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  private native long dispatch_wglCreateAssociatedContextAMD0(int id, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreateAssociatedContextAttribsAMD(UINT id, HANDLE hShareContext, const int *  attribList); </code> <br>Part of <code>WGL_AMD_gpu_association</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  public long wglCreateAssociatedContextAttribsAMD(int id, long hShareContext, IntBuffer attribList)  {

    if (!Buffers.isDirect(attribList))
      throw new GLException("Argument \"attribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateAssociatedContextAttribsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateAssociatedContextAttribsAMD"));
    }
        return dispatch_wglCreateAssociatedContextAttribsAMD0(id, hShareContext, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateAssociatedContextAttribsAMD(UINT id, HANDLE hShareContext, const int *  attribList); </code> <br>Part of <code>WGL_AMD_gpu_association</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreateAssociatedContextAttribsAMD0(int id, long hShareContext, Object attribList, int attribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreateBufferRegionARB(HANDLE hDC, int iLayerPlane, UINT uType); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public long wglCreateBufferRegionARB(long hDC, int iLayerPlane, int uType)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateBufferRegionARB"));
    }
        return dispatch_wglCreateBufferRegionARB0(hDC, iLayerPlane, uType, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateBufferRegionARB(HANDLE hDC, int iLayerPlane, UINT uType); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  private native long dispatch_wglCreateBufferRegionARB0(long hDC, int iLayerPlane, int uType, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreateContextAttribsARB(HANDLE hDC, HANDLE hShareContext, const int *  attribList); </code> <br>Part of <code>WGL_ARB_create_context</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  public long wglCreateContextAttribsARB(long hDC, long hShareContext, IntBuffer attribList)  {

    if (!Buffers.isDirect(attribList))
      throw new GLException("Argument \"attribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateContextAttribsARB"));
    }
        return dispatch_wglCreateContextAttribsARB0(hDC, hShareContext, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateContextAttribsARB(HANDLE hDC, HANDLE hShareContext, const int *  attribList); </code> <br>Part of <code>WGL_ARB_create_context</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreateContextAttribsARB0(long hDC, long hShareContext, Object attribList, int attribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLboolean wglCreateDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public boolean wglCreateDisplayColorTableEXT(short id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreateDisplayColorTableEXT"));
    }
        return dispatch_wglCreateDisplayColorTableEXT0(id, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglCreateDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  private native boolean dispatch_wglCreateDisplayColorTableEXT0(short id, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferARB(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  public long wglCreatePbufferARB(long hDC, int iPixelFormat, int iWidth, int iHeight, IntBuffer piAttribList)  {

    if (!Buffers.isDirect(piAttribList))
      throw new GLException("Argument \"piAttribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreatePbufferARB"));
    }
        return dispatch_wglCreatePbufferARB0(hDC, iPixelFormat, iWidth, iHeight, piAttribList, Buffers.getDirectBufferByteOffset(piAttribList), __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferARB(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreatePbufferARB0(long hDC, int iPixelFormat, int iWidth, int iHeight, Object piAttribList, int piAttribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferEXT(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  public long wglCreatePbufferEXT(long hDC, int iPixelFormat, int iWidth, int iHeight, IntBuffer piAttribList)  {

    if (!Buffers.isDirect(piAttribList))
      throw new GLException("Argument \"piAttribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglCreatePbufferEXT"));
    }
        return dispatch_wglCreatePbufferEXT0(hDC, iPixelFormat, iWidth, iHeight, piAttribList, Buffers.getDirectBufferByteOffset(piAttribList), __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferEXT(HANDLE hDC, int iPixelFormat, int iWidth, int iHeight, const int *  piAttribList); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreatePbufferEXT0(long hDC, int iPixelFormat, int iWidth, int iHeight, Object piAttribList, int piAttribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXCloseDeviceNV(HANDLE hDevice); </code> <br>Part of <code>WGL_NV_DX_interop</code>   */
  public boolean wglDXCloseDeviceNV(long hDevice)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXCloseDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXCloseDeviceNV"));
    }
        return dispatch_wglDXCloseDeviceNV0(hDevice, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXCloseDeviceNV(HANDLE hDevice); </code> <br>Part of <code>WGL_NV_DX_interop</code>   */
  private native boolean dispatch_wglDXCloseDeviceNV0(long hDevice, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE *  hObjects); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param hObjects a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean wglDXLockObjectsNV(long hDevice, int count, PointerBuffer hObjects)  {

    if (!Buffers.isDirect(hObjects))
      throw new GLException("Argument \"hObjects\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXLockObjectsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXLockObjectsNV"));
    }
        return dispatch_wglDXLockObjectsNV0(hDevice, count, hObjects != null ? hObjects.getBuffer() : null, Buffers.getDirectBufferByteOffset(hObjects), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE *  hObjects); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param hObjects a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_wglDXLockObjectsNV0(long hDevice, int count, Object hObjects, int hObjects_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXObjectAccessNV(HANDLE hObject, GLenum access); </code> <br>Part of <code>WGL_NV_DX_interop</code>   */
  public boolean wglDXObjectAccessNV(long hObject, int access)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXObjectAccessNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXObjectAccessNV"));
    }
        return dispatch_wglDXObjectAccessNV0(hObject, access, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXObjectAccessNV(HANDLE hObject, GLenum access); </code> <br>Part of <code>WGL_NV_DX_interop</code>   */
  private native boolean dispatch_wglDXObjectAccessNV0(long hObject, int access, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglDXOpenDeviceNV(LPVOID dxDevice); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param dxDevice a direct only {@link java.nio.Buffer}   */
  public long wglDXOpenDeviceNV(Buffer dxDevice)  {

    if (!Buffers.isDirect(dxDevice))
      throw new GLException("Argument \"dxDevice\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXOpenDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXOpenDeviceNV"));
    }
        return dispatch_wglDXOpenDeviceNV0(dxDevice, Buffers.getDirectBufferByteOffset(dxDevice), __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglDXOpenDeviceNV(LPVOID dxDevice); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param dxDevice a direct only {@link java.nio.Buffer}   */
  private native long dispatch_wglDXOpenDeviceNV0(Object dxDevice, int dxDevice_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglDXRegisterObjectNV(HANDLE hDevice, LPVOID dxObject, GLuint name, GLenum type, GLenum access); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param dxObject a direct only {@link java.nio.Buffer}   */
  public long wglDXRegisterObjectNV(long hDevice, Buffer dxObject, int name, int type, int access)  {

    if (!Buffers.isDirect(dxObject))
      throw new GLException("Argument \"dxObject\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXRegisterObjectNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXRegisterObjectNV"));
    }
        return dispatch_wglDXRegisterObjectNV0(hDevice, dxObject, Buffers.getDirectBufferByteOffset(dxObject), name, type, access, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglDXRegisterObjectNV(HANDLE hDevice, LPVOID dxObject, GLuint name, GLenum type, GLenum access); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param dxObject a direct only {@link java.nio.Buffer}   */
  private native long dispatch_wglDXRegisterObjectNV0(long hDevice, Object dxObject, int dxObject_byte_offset, int name, int type, int access, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXSetResourceShareHandleNV(LPVOID dxObject, HANDLE shareHandle); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param dxObject a direct only {@link java.nio.Buffer}   */
  public boolean wglDXSetResourceShareHandleNV(Buffer dxObject, long shareHandle)  {

    if (!Buffers.isDirect(dxObject))
      throw new GLException("Argument \"dxObject\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXSetResourceShareHandleNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXSetResourceShareHandleNV"));
    }
        return dispatch_wglDXSetResourceShareHandleNV0(dxObject, Buffers.getDirectBufferByteOffset(dxObject), shareHandle, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXSetResourceShareHandleNV(LPVOID dxObject, HANDLE shareHandle); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param dxObject a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_wglDXSetResourceShareHandleNV0(Object dxObject, int dxObject_byte_offset, long shareHandle, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE *  hObjects); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param hObjects a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean wglDXUnlockObjectsNV(long hDevice, int count, PointerBuffer hObjects)  {

    if (!Buffers.isDirect(hObjects))
      throw new GLException("Argument \"hObjects\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXUnlockObjectsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXUnlockObjectsNV"));
    }
        return dispatch_wglDXUnlockObjectsNV0(hDevice, count, hObjects != null ? hObjects.getBuffer() : null, Buffers.getDirectBufferByteOffset(hObjects), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE *  hObjects); </code> <br>Part of <code>WGL_NV_DX_interop</code>
      @param hObjects a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_wglDXUnlockObjectsNV0(long hDevice, int count, Object hObjects, int hObjects_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject); </code> <br>Part of <code>WGL_NV_DX_interop</code>   */
  public boolean wglDXUnregisterObjectNV(long hDevice, long hObject)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDXUnregisterObjectNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDXUnregisterObjectNV"));
    }
        return dispatch_wglDXUnregisterObjectNV0(hDevice, hObject, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject); </code> <br>Part of <code>WGL_NV_DX_interop</code>   */
  private native boolean dispatch_wglDXUnregisterObjectNV0(long hDevice, long hObject, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDeleteAssociatedContextAMD(HANDLE hglrc); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  public boolean wglDeleteAssociatedContextAMD(long hglrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDeleteAssociatedContextAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDeleteAssociatedContextAMD"));
    }
        return dispatch_wglDeleteAssociatedContextAMD0(hglrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDeleteAssociatedContextAMD(HANDLE hglrc); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  private native boolean dispatch_wglDeleteAssociatedContextAMD0(long hglrc, long procAddress);

  /** Entry point to C language function: <code> void wglDeleteBufferRegionARB(HANDLE hRegion); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public void wglDeleteBufferRegionARB(long hRegion)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDeleteBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDeleteBufferRegionARB"));
    }
        dispatch_wglDeleteBufferRegionARB0(hRegion, __addr_);
  }

  /** Entry point to C language function: <code> void wglDeleteBufferRegionARB(HANDLE hRegion); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  private native void dispatch_wglDeleteBufferRegionARB0(long hRegion, long procAddress);

  /** Entry point to C language function: <code> void wglDestroyDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public void wglDestroyDisplayColorTableEXT(short id)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDestroyDisplayColorTableEXT"));
    }
        dispatch_wglDestroyDisplayColorTableEXT0(id, __addr_);
  }

  /** Entry point to C language function: <code> void wglDestroyDisplayColorTableEXT(GLushort id); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  private native void dispatch_wglDestroyDisplayColorTableEXT0(short id, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferARB(HANDLE hPbuffer); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public boolean wglDestroyPbufferARB(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyPbufferARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDestroyPbufferARB"));
    }
        return dispatch_wglDestroyPbufferARB0(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferARB(HANDLE hPbuffer); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  private native boolean dispatch_wglDestroyPbufferARB0(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferEXT(HANDLE hPbuffer); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public boolean wglDestroyPbufferEXT(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyPbufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDestroyPbufferEXT"));
    }
        return dispatch_wglDestroyPbufferEXT0(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferEXT(HANDLE hPbuffer); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  private native boolean dispatch_wglDestroyPbufferEXT0(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDisableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public boolean wglDisableFrameLockI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDisableFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglDisableFrameLockI3D"));
    }
        return dispatch_wglDisableFrameLockI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDisableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  private native boolean dispatch_wglDisableFrameLockI3D0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglEnableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public boolean wglEnableFrameLockI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEnableFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglEnableFrameLockI3D"));
    }
        return dispatch_wglEnableFrameLockI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglEnableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  private native boolean dispatch_wglEnableFrameLockI3D0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglEndFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public boolean wglEndFrameTrackingI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEndFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglEndFrameTrackingI3D"));
    }
        return dispatch_wglEndFrameTrackingI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglEndFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  private native boolean dispatch_wglEndFrameTrackingI3D0(long procAddress);

  /** Entry point to C language function: <code> void wglFreeMemoryNV(LPVOID pointer); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void wglFreeMemoryNV(Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglFreeMemoryNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglFreeMemoryNV"));
    }
        dispatch_wglFreeMemoryNV0(pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void wglFreeMemoryNV(LPVOID pointer); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_wglFreeMemoryNV0(Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> UINT wglGetContextGPUIDAMD(HANDLE hglrc); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  public int wglGetContextGPUIDAMD(long hglrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetContextGPUIDAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetContextGPUIDAMD"));
    }
        return dispatch_wglGetContextGPUIDAMD0(hglrc, __addr_);
  }

  /** Entry point to C language function: <code> UINT wglGetContextGPUIDAMD(HANDLE hglrc); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  private native int dispatch_wglGetContextGPUIDAMD0(long hglrc, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglGetCurrentAssociatedContextAMD(void); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  public long wglGetCurrentAssociatedContextAMD()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetCurrentAssociatedContextAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetCurrentAssociatedContextAMD"));
    }
        return dispatch_wglGetCurrentAssociatedContextAMD0(__addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetCurrentAssociatedContextAMD(void); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  private native long dispatch_wglGetCurrentAssociatedContextAMD0(long procAddress);

  /** Entry point to C language function: <code> HANDLE wglGetCurrentReadDC(void); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public long wglGetCurrentReadDC()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetCurrentReadDC;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetCurrentReadDC"));
    }
        return dispatch_wglGetCurrentReadDC0(__addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetCurrentReadDC(void); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  private native long dispatch_wglGetCurrentReadDC0(long procAddress);

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringARB(HANDLE hdc); </code> <br>Part of <code>WGL_ARB_extensions_string</code>   */
  public String wglGetExtensionsStringARB(long hdc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetExtensionsStringARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetExtensionsStringARB"));
    }
        return dispatch_wglGetExtensionsStringARB0(hdc, __addr_);
  }

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringARB(HANDLE hdc); </code> <br>Part of <code>WGL_ARB_extensions_string</code>   */
  private native String dispatch_wglGetExtensionsStringARB0(long hdc, long procAddress);

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringEXT(void); </code> <br>Part of <code>WGL_EXT_extensions_string</code>   */
  public String wglGetExtensionsStringEXT()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetExtensionsStringEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetExtensionsStringEXT"));
    }
        return dispatch_wglGetExtensionsStringEXT0(__addr_);
  }

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringEXT(void); </code> <br>Part of <code>WGL_EXT_extensions_string</code>   */
  private native String dispatch_wglGetExtensionsStringEXT0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetFrameUsageI3D(float *  pUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param pUsage a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglGetFrameUsageI3D(FloatBuffer pUsage)  {

    if (!Buffers.isDirect(pUsage))
      throw new GLException("Argument \"pUsage\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetFrameUsageI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetFrameUsageI3D"));
    }
        return dispatch_wglGetFrameUsageI3D0(pUsage, Buffers.getDirectBufferByteOffset(pUsage), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetFrameUsageI3D(float *  pUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param pUsage a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetFrameUsageI3D0(Object pUsage, int pUsage_byte_offset, long procAddress);

  /** Entry point to C language function: <code> UINT wglGetGPUIDsAMD(UINT maxCount, UINT *  ids); </code> <br>Part of <code>WGL_AMD_gpu_association</code>
      @param ids a direct only {@link java.nio.IntBuffer}   */
  public int wglGetGPUIDsAMD(int maxCount, IntBuffer ids)  {

    if (!Buffers.isDirect(ids))
      throw new GLException("Argument \"ids\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetGPUIDsAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetGPUIDsAMD"));
    }
        return dispatch_wglGetGPUIDsAMD0(maxCount, ids, Buffers.getDirectBufferByteOffset(ids), __addr_);
  }

  /** Entry point to C language function: <code> UINT wglGetGPUIDsAMD(UINT maxCount, UINT *  ids); </code> <br>Part of <code>WGL_AMD_gpu_association</code>
      @param ids a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_wglGetGPUIDsAMD0(int maxCount, Object ids, int ids_byte_offset, long procAddress);

  /** Entry point to C language function: <code> INT wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, LPVOID data); </code> <br>Part of <code>WGL_AMD_gpu_association</code>
      @param data a direct only {@link java.nio.Buffer}   */
  public int wglGetGPUInfoAMD(int id, int property, int dataType, int size, Buffer data)  {

    if (!Buffers.isDirect(data))
      throw new GLException("Argument \"data\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetGPUInfoAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetGPUInfoAMD"));
    }
        return dispatch_wglGetGPUInfoAMD0(id, property, dataType, size, data, Buffers.getDirectBufferByteOffset(data), __addr_);
  }

  /** Entry point to C language function: <code> INT wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, LPVOID data); </code> <br>Part of <code>WGL_AMD_gpu_association</code>
      @param data a direct only {@link java.nio.Buffer}   */
  private native int dispatch_wglGetGPUInfoAMD0(int id, int property, int dataType, int size, Object data, int data_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCARB(HANDLE hPbuffer); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public long wglGetPbufferDCARB(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPbufferDCARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPbufferDCARB"));
    }
        return dispatch_wglGetPbufferDCARB0(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCARB(HANDLE hPbuffer); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  private native long dispatch_wglGetPbufferDCARB0(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCEXT(HANDLE hPbuffer); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public long wglGetPbufferDCEXT(long hPbuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPbufferDCEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPbufferDCEXT"));
    }
        return dispatch_wglGetPbufferDCEXT0(hPbuffer, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCEXT(HANDLE hPbuffer); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  private native long dispatch_wglGetPbufferDCEXT0(long hPbuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param pfValues a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglGetPixelFormatAttribfvARB(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, FloatBuffer pfValues)  {

    if (!Buffers.isDirect(piAttributes))
      throw new GLException("Argument \"piAttributes\" is not a direct buffer");
    if (!Buffers.isDirect(pfValues))
      throw new GLException("Argument \"pfValues\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPixelFormatAttribfvARB"));
    }
        return dispatch_wglGetPixelFormatAttribfvARB0(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.getDirectBufferByteOffset(piAttributes), pfValues, Buffers.getDirectBufferByteOffset(pfValues), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param pfValues a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribfvARB0(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, Object pfValues, int pfValues_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param pfValues a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglGetPixelFormatAttribfvEXT(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, FloatBuffer pfValues)  {

    if (!Buffers.isDirect(piAttributes))
      throw new GLException("Argument \"piAttributes\" is not a direct buffer");
    if (!Buffers.isDirect(pfValues))
      throw new GLException("Argument \"pfValues\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPixelFormatAttribfvEXT"));
    }
        return dispatch_wglGetPixelFormatAttribfvEXT0(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.getDirectBufferByteOffset(piAttributes), pfValues, Buffers.getDirectBufferByteOffset(pfValues), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, FLOAT *  pfValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param pfValues a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribfvEXT0(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, Object pfValues, int pfValues_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param piValues a direct only {@link java.nio.IntBuffer}   */
  public boolean wglGetPixelFormatAttribivARB(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, IntBuffer piValues)  {

    if (!Buffers.isDirect(piAttributes))
      throw new GLException("Argument \"piAttributes\" is not a direct buffer");
    if (!Buffers.isDirect(piValues))
      throw new GLException("Argument \"piValues\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPixelFormatAttribivARB"));
    }
        return dispatch_wglGetPixelFormatAttribivARB0(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.getDirectBufferByteOffset(piAttributes), piValues, Buffers.getDirectBufferByteOffset(piValues), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivARB(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param piValues a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribivARB0(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, Object piValues, int piValues_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param piValues a direct only {@link java.nio.IntBuffer}   */
  public boolean wglGetPixelFormatAttribivEXT(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, IntBuffer piAttributes, IntBuffer piValues)  {

    if (!Buffers.isDirect(piAttributes))
      throw new GLException("Argument \"piAttributes\" is not a direct buffer");
    if (!Buffers.isDirect(piValues))
      throw new GLException("Argument \"piValues\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetPixelFormatAttribivEXT"));
    }
        return dispatch_wglGetPixelFormatAttribivEXT0(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, Buffers.getDirectBufferByteOffset(piAttributes), piValues, Buffers.getDirectBufferByteOffset(piValues), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivEXT(HANDLE hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *  piAttributes, int *  piValues); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param piAttributes a direct only {@link java.nio.IntBuffer}
      @param piValues a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribivEXT0(long hdc, int iPixelFormat, int iLayerPlane, int nAttributes, Object piAttributes, int piAttributes_byte_offset, Object piValues, int piValues_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int wglGetSwapIntervalEXT(void); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public int wglGetSwapIntervalEXT()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglGetSwapIntervalEXT"));
    }
        return dispatch_wglGetSwapIntervalEXT0(__addr_);
  }

  /** Entry point to C language function: <code> int wglGetSwapIntervalEXT(void); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  private native int dispatch_wglGetSwapIntervalEXT0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglIsEnabledFrameLockI3D(BOOL *  pFlag); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param pFlag a direct only {@link java.nio.ByteBuffer}   */
  public boolean wglIsEnabledFrameLockI3D(ByteBuffer pFlag)  {

    if (!Buffers.isDirect(pFlag))
      throw new GLException("Argument \"pFlag\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglIsEnabledFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglIsEnabledFrameLockI3D"));
    }
        return dispatch_wglIsEnabledFrameLockI3D0(pFlag, Buffers.getDirectBufferByteOffset(pFlag), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglIsEnabledFrameLockI3D(BOOL *  pFlag); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param pFlag a direct only {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_wglIsEnabledFrameLockI3D0(Object pFlag, int pFlag_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglJoinSwapGroupNV(HANDLE hDC, GLuint group); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglJoinSwapGroupNV(long hDC, int group)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglJoinSwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglJoinSwapGroupNV"));
    }
        return dispatch_wglJoinSwapGroupNV0(hDC, group, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglJoinSwapGroupNV(HANDLE hDC, GLuint group); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  private native boolean dispatch_wglJoinSwapGroupNV0(long hDC, int group, long procAddress);

  /** Entry point to C language function: <code> GLboolean wglLoadDisplayColorTableEXT(const GLushort *  table, GLuint length); </code> <br>Part of <code>WGL_EXT_display_color_table</code>
      @param table a direct only {@link java.nio.ShortBuffer}   */
  public boolean wglLoadDisplayColorTableEXT(ShortBuffer table, int length)  {

    if (!Buffers.isDirect(table))
      throw new GLException("Argument \"table\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglLoadDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglLoadDisplayColorTableEXT"));
    }
        return dispatch_wglLoadDisplayColorTableEXT0(table, Buffers.getDirectBufferByteOffset(table), length, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglLoadDisplayColorTableEXT(const GLushort *  table, GLuint length); </code> <br>Part of <code>WGL_EXT_display_color_table</code>
      @param table a direct only {@link java.nio.ShortBuffer}   */
  private native boolean dispatch_wglLoadDisplayColorTableEXT0(Object table, int table_byte_offset, int length, long procAddress);

  /** Entry point to C language function: <code> BOOL wglMakeAssociatedContextCurrentAMD(HANDLE hglrc); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  public boolean wglMakeAssociatedContextCurrentAMD(long hglrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglMakeAssociatedContextCurrentAMD;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglMakeAssociatedContextCurrentAMD"));
    }
        return dispatch_wglMakeAssociatedContextCurrentAMD0(hglrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglMakeAssociatedContextCurrentAMD(HANDLE hglrc); </code> <br>Part of <code>WGL_AMD_gpu_association</code>   */
  private native boolean dispatch_wglMakeAssociatedContextCurrentAMD0(long hglrc, long procAddress);

  /** Entry point to C language function: <code> BOOL wglMakeContextCurrent(HANDLE hDrawDC, HANDLE hReadDC, HANDLE hglrc); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public boolean wglMakeContextCurrent(long hDrawDC, long hReadDC, long hglrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglMakeContextCurrent;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglMakeContextCurrent"));
    }
        return dispatch_wglMakeContextCurrent0(hDrawDC, hReadDC, hglrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglMakeContextCurrent(HANDLE hDrawDC, HANDLE hReadDC, HANDLE hglrc); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  private native boolean dispatch_wglMakeContextCurrent0(long hDrawDC, long hReadDC, long hglrc, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameCountNV(HANDLE hDC, GLuint *  count); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryFrameCountNV(long hDC, IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryFrameCountNV"));
    }
        return dispatch_wglQueryFrameCountNV0(hDC, count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameCountNV(HANDLE hDC, GLuint *  count); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryFrameCountNV0(long hDC, Object count, int count_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameLockMasterI3D(BOOL *  pFlag); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param pFlag a direct only {@link java.nio.ByteBuffer}   */
  public boolean wglQueryFrameLockMasterI3D(ByteBuffer pFlag)  {

    if (!Buffers.isDirect(pFlag))
      throw new GLException("Argument \"pFlag\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameLockMasterI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryFrameLockMasterI3D"));
    }
        return dispatch_wglQueryFrameLockMasterI3D0(pFlag, Buffers.getDirectBufferByteOffset(pFlag), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameLockMasterI3D(BOOL *  pFlag); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param pFlag a direct only {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_wglQueryFrameLockMasterI3D0(Object pFlag, int pFlag_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameTrackingI3D(DWORD *  pFrameCount, DWORD *  pMissedFrames, float *  pLastMissedUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param pFrameCount a direct only {@link java.nio.IntBuffer}
      @param pMissedFrames a direct only {@link java.nio.IntBuffer}
      @param pLastMissedUsage a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglQueryFrameTrackingI3D(IntBuffer pFrameCount, IntBuffer pMissedFrames, FloatBuffer pLastMissedUsage)  {

    if (!Buffers.isDirect(pFrameCount))
      throw new GLException("Argument \"pFrameCount\" is not a direct buffer");
    if (!Buffers.isDirect(pMissedFrames))
      throw new GLException("Argument \"pMissedFrames\" is not a direct buffer");
    if (!Buffers.isDirect(pLastMissedUsage))
      throw new GLException("Argument \"pLastMissedUsage\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryFrameTrackingI3D"));
    }
        return dispatch_wglQueryFrameTrackingI3D0(pFrameCount, Buffers.getDirectBufferByteOffset(pFrameCount), pMissedFrames, Buffers.getDirectBufferByteOffset(pMissedFrames), pLastMissedUsage, Buffers.getDirectBufferByteOffset(pLastMissedUsage), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameTrackingI3D(DWORD *  pFrameCount, DWORD *  pMissedFrames, float *  pLastMissedUsage); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param pFrameCount a direct only {@link java.nio.IntBuffer}
      @param pMissedFrames a direct only {@link java.nio.IntBuffer}
      @param pLastMissedUsage a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglQueryFrameTrackingI3D0(Object pFrameCount, int pFrameCount_byte_offset, Object pMissedFrames, int pMissedFrames_byte_offset, Object pLastMissedUsage, int pLastMissedUsage_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryMaxSwapGroupsNV(HANDLE hDC, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryMaxSwapGroupsNV(long hDC, IntBuffer maxGroups, IntBuffer maxBarriers)  {

    if (!Buffers.isDirect(maxGroups))
      throw new GLException("Argument \"maxGroups\" is not a direct buffer");
    if (!Buffers.isDirect(maxBarriers))
      throw new GLException("Argument \"maxBarriers\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryMaxSwapGroupsNV"));
    }
        return dispatch_wglQueryMaxSwapGroupsNV0(hDC, maxGroups, Buffers.getDirectBufferByteOffset(maxGroups), maxBarriers, Buffers.getDirectBufferByteOffset(maxBarriers), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryMaxSwapGroupsNV(HANDLE hDC, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryMaxSwapGroupsNV0(long hDC, Object maxGroups, int maxGroups_byte_offset, Object maxBarriers, int maxBarriers_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryPbufferARB(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryPbufferARB(long hPbuffer, int iAttribute, IntBuffer piValue)  {

    if (!Buffers.isDirect(piValue))
      throw new GLException("Argument \"piValue\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryPbufferARB"));
    }
        return dispatch_wglQueryPbufferARB0(hPbuffer, iAttribute, piValue, Buffers.getDirectBufferByteOffset(piValue), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferARB(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryPbufferARB0(long hPbuffer, int iAttribute, Object piValue, int piValue_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryPbufferEXT(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryPbufferEXT(long hPbuffer, int iAttribute, IntBuffer piValue)  {

    if (!Buffers.isDirect(piValue))
      throw new GLException("Argument \"piValue\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQueryPbufferEXT"));
    }
        return dispatch_wglQueryPbufferEXT0(hPbuffer, iAttribute, piValue, Buffers.getDirectBufferByteOffset(piValue), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferEXT(HANDLE hPbuffer, int iAttribute, int *  piValue); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param piValue a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryPbufferEXT0(long hPbuffer, int iAttribute, Object piValue, int piValue_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQuerySwapGroupNV(HANDLE hDC, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQuerySwapGroupNV(long hDC, IntBuffer group, IntBuffer barrier)  {

    if (!Buffers.isDirect(group))
      throw new GLException("Argument \"group\" is not a direct buffer");
    if (!Buffers.isDirect(barrier))
      throw new GLException("Argument \"barrier\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglQuerySwapGroupNV"));
    }
        return dispatch_wglQuerySwapGroupNV0(hDC, group, Buffers.getDirectBufferByteOffset(group), barrier, Buffers.getDirectBufferByteOffset(barrier), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQuerySwapGroupNV(HANDLE hDC, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQuerySwapGroupNV0(long hDC, Object group, int group_byte_offset, Object barrier, int barrier_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int wglReleasePbufferDCARB(HANDLE hPbuffer, HANDLE hDC); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public int wglReleasePbufferDCARB(long hPbuffer, long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleasePbufferDCARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglReleasePbufferDCARB"));
    }
        return dispatch_wglReleasePbufferDCARB0(hPbuffer, hDC, __addr_);
  }

  /** Entry point to C language function: <code> int wglReleasePbufferDCARB(HANDLE hPbuffer, HANDLE hDC); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  private native int dispatch_wglReleasePbufferDCARB0(long hPbuffer, long hDC, long procAddress);

  /** Entry point to C language function: <code> int wglReleasePbufferDCEXT(HANDLE hPbuffer, HANDLE hDC); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public int wglReleasePbufferDCEXT(long hPbuffer, long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleasePbufferDCEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglReleasePbufferDCEXT"));
    }
        return dispatch_wglReleasePbufferDCEXT0(hPbuffer, hDC, __addr_);
  }

  /** Entry point to C language function: <code> int wglReleasePbufferDCEXT(HANDLE hPbuffer, HANDLE hDC); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  private native int dispatch_wglReleasePbufferDCEXT0(long hPbuffer, long hDC, long procAddress);

  /** Entry point to C language function: <code> BOOL wglReleaseTexImageARB(HANDLE hPbuffer, int iBuffer); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public boolean wglReleaseTexImageARB(long hPbuffer, int iBuffer)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleaseTexImageARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglReleaseTexImageARB"));
    }
        return dispatch_wglReleaseTexImageARB0(hPbuffer, iBuffer, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglReleaseTexImageARB(HANDLE hPbuffer, int iBuffer); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  private native boolean dispatch_wglReleaseTexImageARB0(long hPbuffer, int iBuffer, long procAddress);

  /** Entry point to C language function: <code> BOOL wglResetFrameCountNV(HANDLE hDC); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglResetFrameCountNV(long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglResetFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglResetFrameCountNV"));
    }
        return dispatch_wglResetFrameCountNV0(hDC, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglResetFrameCountNV(HANDLE hDC); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  private native boolean dispatch_wglResetFrameCountNV0(long hDC, long procAddress);

  /** Entry point to C language function: <code> BOOL wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public boolean wglRestoreBufferRegionARB(long hRegion, int x, int y, int width, int height, int xSrc, int ySrc)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglRestoreBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglRestoreBufferRegionARB"));
    }
        return dispatch_wglRestoreBufferRegionARB0(hRegion, x, y, width, height, xSrc, ySrc, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  private native boolean dispatch_wglRestoreBufferRegionARB0(long hRegion, int x, int y, int width, int height, int xSrc, int ySrc, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public boolean wglSaveBufferRegionARB(long hRegion, int x, int y, int width, int height)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSaveBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglSaveBufferRegionARB"));
    }
        return dispatch_wglSaveBufferRegionARB0(hRegion, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  private native boolean dispatch_wglSaveBufferRegionARB0(long hRegion, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSetPbufferAttribARB(HANDLE hPbuffer, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_render_texture</code>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  public boolean wglSetPbufferAttribARB(long hPbuffer, IntBuffer piAttribList)  {

    if (!Buffers.isDirect(piAttribList))
      throw new GLException("Argument \"piAttribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSetPbufferAttribARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglSetPbufferAttribARB"));
    }
        return dispatch_wglSetPbufferAttribARB0(hPbuffer, piAttribList, Buffers.getDirectBufferByteOffset(piAttribList), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSetPbufferAttribARB(HANDLE hPbuffer, const int *  piAttribList); </code> <br>Part of <code>WGL_ARB_render_texture</code>
      @param piAttribList a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglSetPbufferAttribARB0(long hPbuffer, Object piAttribList, int piAttribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSetStereoEmitterState3DL(HANDLE hDC, UINT uState); </code> <br>Part of <code>WGL_3DL_stereo_control</code>   */
  public boolean wglSetStereoEmitterState3DL(long hDC, int uState)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSetStereoEmitterState3DL;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglSetStereoEmitterState3DL"));
    }
        return dispatch_wglSetStereoEmitterState3DL0(hDC, uState, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSetStereoEmitterState3DL(HANDLE hDC, UINT uState); </code> <br>Part of <code>WGL_3DL_stereo_control</code>   */
  private native boolean dispatch_wglSetStereoEmitterState3DL0(long hDC, int uState, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSwapIntervalEXT(int interval); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public boolean wglSwapIntervalEXT(int interval)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "wglSwapIntervalEXT"));
    }
        return dispatch_wglSwapIntervalEXT0(interval, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSwapIntervalEXT(int interval); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  private native boolean dispatch_wglSwapIntervalEXT0(int interval, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public WGLExtImpl(WindowsWGLContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private WindowsWGLContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class WGLExtImpl
