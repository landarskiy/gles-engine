/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Tue Mar 11 04:19:15 CET 2014 ----! */

package jogamp.opengl.x11.glx;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import jogamp.nativewindow.x11.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GLXExtImpl implements GLXExt{
  /** Entry point to C language function: <code> GLvoid *  glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>   */
  public ByteBuffer glXAllocateMemoryNV(int size, float readfreq, float writefreq, float priority)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXAllocateMemoryNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXAllocateMemoryNV"));
    }
    final ByteBuffer _res;
    _res = dispatch_glXAllocateMemoryNV0(size, readfreq, writefreq, priority, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> GLvoid *  glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>   */
  private native ByteBuffer dispatch_glXAllocateMemoryNV0(int size, float readfreq, float writefreq, float priority, long procAddress);

  /** Entry point to C language function: <code> int glXBindChannelToWindowSGIX(Display *  display, int screen, int channel, XID window); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXBindChannelToWindowSGIX(long display, int screen, int channel, long window)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindChannelToWindowSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindChannelToWindowSGIX"));
    }
        return dispatch_glXBindChannelToWindowSGIX0(display, screen, channel, window, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindChannelToWindowSGIX(Display *  display, int screen, int channel, XID window); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  private native int dispatch_glXBindChannelToWindowSGIX0(long display, int screen, int channel, long window, long procAddress);

  /** Entry point to C language function: <code> Bool glXBindSwapBarrierNV(Display *  dpy, GLuint group, GLuint barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXBindSwapBarrierNV(long dpy, int group, int barrier)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindSwapBarrierNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindSwapBarrierNV"));
    }
        return dispatch_glXBindSwapBarrierNV0(dpy, group, barrier, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXBindSwapBarrierNV(Display *  dpy, GLuint group, GLuint barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  private native boolean dispatch_glXBindSwapBarrierNV0(long dpy, int group, int barrier, long procAddress);

  /** Entry point to C language function: <code> void glXBindSwapBarrierSGIX(Display *  dpy, XID drawable, int barrier); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>   */
  public void glXBindSwapBarrierSGIX(long dpy, long drawable, int barrier)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindSwapBarrierSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindSwapBarrierSGIX"));
    }
        dispatch_glXBindSwapBarrierSGIX0(dpy, drawable, barrier, __addr_);
  }

  /** Entry point to C language function: <code> void glXBindSwapBarrierSGIX(Display *  dpy, XID drawable, int barrier); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>   */
  private native void dispatch_glXBindSwapBarrierSGIX0(long dpy, long drawable, int barrier, long procAddress);

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public void glXBindTexImageEXT(long dpy, long drawable, int buffer, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindTexImageEXT"));
    }
        dispatch_glXBindTexImageEXT0(dpy, drawable, buffer, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native void dispatch_glXBindTexImageEXT0(long dpy, long drawable, int buffer, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXBindVideoCaptureDeviceNV(Display *  dpy, unsigned int video_capture_slot, XID device); </code> <br>Part of <code>GLX_NV_video_capture</code>   */
  public int glXBindVideoCaptureDeviceNV(long dpy, int video_capture_slot, long device)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindVideoCaptureDeviceNV"));
    }
        return dispatch_glXBindVideoCaptureDeviceNV0(dpy, video_capture_slot, device, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoCaptureDeviceNV(Display *  dpy, unsigned int video_capture_slot, XID device); </code> <br>Part of <code>GLX_NV_video_capture</code>   */
  private native int dispatch_glXBindVideoCaptureDeviceNV0(long dpy, int video_capture_slot, long device, long procAddress);

  /** Entry point to C language function: <code> int glXBindVideoDeviceNV(Display *  dpy, unsigned int video_slot, unsigned int video_device, const int *  attrib_list); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public int glXBindVideoDeviceNV(long dpy, int video_slot, int video_device, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindVideoDeviceNV"));
    }
        return dispatch_glXBindVideoDeviceNV0(dpy, video_slot, video_device, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoDeviceNV(Display *  dpy, unsigned int video_slot, unsigned int video_device, const int *  attrib_list); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXBindVideoDeviceNV0(long dpy, int video_slot, int video_device, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXBindVideoImageNV(Display *  dpy, GLXVideoDeviceNV VideoDevice, XID pbuf, int iVideoBuffer); </code> <br>Part of <code>GLX_NV_video_output</code>   */
  public int glXBindVideoImageNV(long dpy, int VideoDevice, long pbuf, int iVideoBuffer)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXBindVideoImageNV"));
    }
        return dispatch_glXBindVideoImageNV0(dpy, VideoDevice, pbuf, iVideoBuffer, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoImageNV(Display *  dpy, GLXVideoDeviceNV VideoDevice, XID pbuf, int iVideoBuffer); </code> <br>Part of <code>GLX_NV_video_output</code>   */
  private native int dispatch_glXBindVideoImageNV0(long dpy, int VideoDevice, long pbuf, int iVideoBuffer, long procAddress);

  /** Entry point to C language function: <code> int glXChannelRectSGIX(Display *  display, int screen, int channel, int x, int y, int w, int h); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXChannelRectSGIX(long display, int screen, int channel, int x, int y, int w, int h)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXChannelRectSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXChannelRectSGIX"));
    }
        return dispatch_glXChannelRectSGIX0(display, screen, channel, x, y, w, h, __addr_);
  }

  /** Entry point to C language function: <code> int glXChannelRectSGIX(Display *  display, int screen, int channel, int x, int y, int w, int h); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  private native int dispatch_glXChannelRectSGIX0(long display, int screen, int channel, int x, int y, int w, int h, long procAddress);

  /** Entry point to C language function: <code> int glXChannelRectSyncSGIX(Display *  display, int screen, int channel, GLenum synctype); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXChannelRectSyncSGIX(long display, int screen, int channel, int synctype)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXChannelRectSyncSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXChannelRectSyncSGIX"));
    }
        return dispatch_glXChannelRectSyncSGIX0(display, screen, channel, synctype, __addr_);
  }

  /** Entry point to C language function: <code> int glXChannelRectSyncSGIX(Display *  display, int screen, int channel, GLenum synctype); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  private native int dispatch_glXChannelRectSyncSGIX0(long display, int screen, int channel, int synctype, long procAddress);

  /** Entry point to C language function: <code> void glXCopyImageSubDataNV(Display *  dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GLX_NV_copy_image</code>   */
  public void glXCopyImageSubDataNV(long dpy, long srcCtx, int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, long dstCtx, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCopyImageSubDataNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCopyImageSubDataNV"));
    }
        dispatch_glXCopyImageSubDataNV0(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopyImageSubDataNV(Display *  dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth); </code> <br>Part of <code>GLX_NV_copy_image</code>   */
  private native void dispatch_glXCopyImageSubDataNV0(long dpy, long srcCtx, int srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, long dstCtx, int dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth, long procAddress);

  /** Entry point to C language function: <code> void glXCopySubBufferMESA(Display *  dpy, XID drawable, int x, int y, int width, int height); </code> <br>Part of <code>GLX_MESA_copy_sub_buffer</code>   */
  public void glXCopySubBufferMESA(long dpy, long drawable, int x, int y, int width, int height)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCopySubBufferMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCopySubBufferMESA"));
    }
        dispatch_glXCopySubBufferMESA0(dpy, drawable, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopySubBufferMESA(Display *  dpy, XID drawable, int x, int y, int width, int height); </code> <br>Part of <code>GLX_MESA_copy_sub_buffer</code>   */
  private native void dispatch_glXCopySubBufferMESA0(long dpy, long drawable, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateContextAttribsARB(Display *  dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *  attrib_list); </code> <br>Part of <code>GLX_ARB_create_context</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long glXCreateContextAttribsARB(long dpy, long config, long share_context, boolean direct, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCreateContextAttribsARB"));
    }
        return dispatch_glXCreateContextAttribsARB0(dpy, config, share_context, direct, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateContextAttribsARB(Display *  dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *  attrib_list); </code> <br>Part of <code>GLX_ARB_create_context</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_glXCreateContextAttribsARB0(long dpy, long config, long share_context, boolean direct, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXCushionSGI(Display *  dpy, XID window, float cushion); </code> <br>Part of <code>GLX_SGI_cushion</code>   */
  public void glXCushionSGI(long dpy, long window, float cushion)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCushionSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXCushionSGI"));
    }
        dispatch_glXCushionSGI0(dpy, window, cushion, __addr_);
  }

  /** Entry point to C language function: <code> void glXCushionSGI(Display *  dpy, XID window, float cushion); </code> <br>Part of <code>GLX_SGI_cushion</code>   */
  private native void dispatch_glXCushionSGI0(long dpy, long window, float cushion, long procAddress);

  /** Entry point to C language function: <code> XID *  glXEnumerateVideoCaptureDevicesNV(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_NV_video_capture</code>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  public PointerBuffer glXEnumerateVideoCaptureDevicesNV(long dpy, int screen, IntBuffer nelements)  {

    if (!Buffers.isDirect(nelements))
      throw new GLException("Argument \"nelements\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXEnumerateVideoCaptureDevicesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXEnumerateVideoCaptureDevicesNV"));
    }
    final ByteBuffer _res;
    _res = dispatch_glXEnumerateVideoCaptureDevicesNV0(dpy, screen, nelements, Buffers.getDirectBufferByteOffset(nelements), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> XID *  glXEnumerateVideoCaptureDevicesNV(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_NV_video_capture</code>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_glXEnumerateVideoCaptureDevicesNV0(long dpy, int screen, Object nelements, int nelements_byte_offset, long procAddress);

  /** Entry point to C language function: <code> unsigned int *  glXEnumerateVideoDevicesNV(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  public IntBuffer glXEnumerateVideoDevicesNV(long dpy, int screen, IntBuffer nelements)  {

    if (!Buffers.isDirect(nelements))
      throw new GLException("Argument \"nelements\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXEnumerateVideoDevicesNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXEnumerateVideoDevicesNV"));
    }
    final ByteBuffer _res;
    _res = dispatch_glXEnumerateVideoDevicesNV0(dpy, screen, nelements, Buffers.getDirectBufferByteOffset(nelements), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res.asIntBuffer();
  }

  /** Entry point to C language function: <code> unsigned int *  glXEnumerateVideoDevicesNV(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_glXEnumerateVideoDevicesNV0(long dpy, int screen, Object nelements, int nelements_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXFreeContextEXT(Display *  dpy, GLXContext context); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public void glXFreeContextEXT(long dpy, long context)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXFreeContextEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXFreeContextEXT"));
    }
        dispatch_glXFreeContextEXT0(dpy, context, __addr_);
  }

  /** Entry point to C language function: <code> void glXFreeContextEXT(Display *  dpy, GLXContext context); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  private native void dispatch_glXFreeContextEXT0(long dpy, long context, long procAddress);

  /** Entry point to C language function: <code> void glXFreeMemoryNV(GLvoid *  pointer); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glXFreeMemoryNV(Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXFreeMemoryNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXFreeMemoryNV"));
    }
        dispatch_glXFreeMemoryNV0(pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void glXFreeMemoryNV(GLvoid *  pointer); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glXFreeMemoryNV0(Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> unsigned int glXGetAGPOffsetMESA(const void *  pointer); </code> <br>Part of <code>GLX_MESA_agp_offset</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public int glXGetAGPOffsetMESA(Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetAGPOffsetMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetAGPOffsetMESA"));
    }
        return dispatch_glXGetAGPOffsetMESA0(pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> unsigned int glXGetAGPOffsetMESA(const void *  pointer); </code> <br>Part of <code>GLX_MESA_agp_offset</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native int dispatch_glXGetAGPOffsetMESA0(Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> XID glXGetContextIDEXT(GLXContext context); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public long glXGetContextIDEXT(long context)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetContextIDEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetContextIDEXT"));
    }
        return dispatch_glXGetContextIDEXT0(context, __addr_);
  }

  /** Entry point to C language function: <code> XID glXGetContextIDEXT(GLXContext context); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  private native long dispatch_glXGetContextIDEXT0(long context, long procAddress);

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplayEXT(void); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public long glXGetCurrentDisplayEXT()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetCurrentDisplayEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetCurrentDisplayEXT"));
    }
        return dispatch_glXGetCurrentDisplayEXT0(__addr_);
  }

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplayEXT(void); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  private native long dispatch_glXGetCurrentDisplayEXT0(long procAddress);

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawableSGI(void); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public long glXGetCurrentReadDrawableSGI()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetCurrentReadDrawableSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetCurrentReadDrawableSGI"));
    }
        return dispatch_glXGetCurrentReadDrawableSGI0(__addr_);
  }

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawableSGI(void); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  private native long dispatch_glXGetCurrentReadDrawableSGI0(long procAddress);

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, XID drawable, int32_t *  numerator, int32_t *  denominator); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param numerator a direct only {@link java.nio.IntBuffer}
      @param denominator a direct only {@link java.nio.IntBuffer}   */
  public boolean glXGetMscRateOML(long dpy, long drawable, IntBuffer numerator, IntBuffer denominator)  {

    if (!Buffers.isDirect(numerator))
      throw new GLException("Argument \"numerator\" is not a direct buffer");
    if (!Buffers.isDirect(denominator))
      throw new GLException("Argument \"denominator\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetMscRateOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetMscRateOML"));
    }
        return dispatch_glXGetMscRateOML0(dpy, drawable, numerator, Buffers.getDirectBufferByteOffset(numerator), denominator, Buffers.getDirectBufferByteOffset(denominator), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display *  dpy, XID drawable, int32_t *  numerator, int32_t *  denominator); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param numerator a direct only {@link java.nio.IntBuffer}
      @param denominator a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXGetMscRateOML0(long dpy, long drawable, Object numerator, int numerator_byte_offset, Object denominator, int denominator_byte_offset, long procAddress);

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddress(const GLubyte *  procName); </code> <br>Part of <code>GLX_VERSION_1_4</code>   */
  public long glXGetProcAddress(String procName)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetProcAddress;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetProcAddress"));
    }
        return dispatch_glXGetProcAddress0(procName, __addr_);
  }

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddress(const GLubyte *  procName); </code> <br>Part of <code>GLX_VERSION_1_4</code>   */
  private native long dispatch_glXGetProcAddress0(String procName, long procAddress);

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddressARB(const GLubyte *  procName); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public long glXGetProcAddressARB(String procName)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetProcAddressARB;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetProcAddressARB"));
    }
        return dispatch_glXGetProcAddressARB0(procName, __addr_);
  }

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddressARB(const GLubyte *  procName); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  private native long dispatch_glXGetProcAddressARB0(String procName, long procAddress);

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, XID drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  public boolean glXGetSyncValuesOML(long dpy, long drawable, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    if (!Buffers.isDirect(ust))
      throw new GLException("Argument \"ust\" is not a direct buffer");
    if (!Buffers.isDirect(msc))
      throw new GLException("Argument \"msc\" is not a direct buffer");
    if (!Buffers.isDirect(sbc))
      throw new GLException("Argument \"sbc\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetSyncValuesOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetSyncValuesOML"));
    }
        return dispatch_glXGetSyncValuesOML0(dpy, drawable, ust, Buffers.getDirectBufferByteOffset(ust), msc, Buffers.getDirectBufferByteOffset(msc), sbc, Buffers.getDirectBufferByteOffset(sbc), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display *  dpy, XID drawable, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXGetSyncValuesOML0(long dpy, long drawable, Object ust, int ust_byte_offset, Object msc, int msc_byte_offset, Object sbc, int sbc_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Status glXGetTransparentIndexSUN(Display *  dpy, XID overlay, XID underlay, long *  pTransparentIndex); </code> <br>Part of <code>GLX_SUN_get_transparent_index</code>
      @param pTransparentIndex a direct only {@link java.nio.LongBuffer}   */
  public int glXGetTransparentIndexSUN(long dpy, long overlay, long underlay, LongBuffer pTransparentIndex)  {

    if (!Buffers.isDirect(pTransparentIndex))
      throw new GLException("Argument \"pTransparentIndex\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetTransparentIndexSUN;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetTransparentIndexSUN"));
    }
        return dispatch_glXGetTransparentIndexSUN0(dpy, overlay, underlay, pTransparentIndex, Buffers.getDirectBufferByteOffset(pTransparentIndex), __addr_);
  }

  /** Entry point to C language function: <code> Status glXGetTransparentIndexSUN(Display *  dpy, XID overlay, XID underlay, long *  pTransparentIndex); </code> <br>Part of <code>GLX_SUN_get_transparent_index</code>
      @param pTransparentIndex a direct only {@link java.nio.LongBuffer}   */
  private native int dispatch_glXGetTransparentIndexSUN0(long dpy, long overlay, long underlay, Object pTransparentIndex, int pTransparentIndex_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoDeviceNV(Display *  dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *  pVideoDevice); </code> <br>Part of <code>GLX_NV_video_output</code>
      @param pVideoDevice a direct only {@link java.nio.IntBuffer}   */
  public int glXGetVideoDeviceNV(long dpy, int screen, int numVideoDevices, IntBuffer pVideoDevice)  {

    if (!Buffers.isDirect(pVideoDevice))
      throw new GLException("Argument \"pVideoDevice\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetVideoDeviceNV"));
    }
        return dispatch_glXGetVideoDeviceNV0(dpy, screen, numVideoDevices, pVideoDevice, Buffers.getDirectBufferByteOffset(pVideoDevice), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoDeviceNV(Display *  dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *  pVideoDevice); </code> <br>Part of <code>GLX_NV_video_output</code>
      @param pVideoDevice a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetVideoDeviceNV0(long dpy, int screen, int numVideoDevices, Object pVideoDevice, int pVideoDevice_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoInfoNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo); </code> <br>Part of <code>GLX_NV_video_output</code>
      @param pulCounterOutputPbuffer a direct only {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct only {@link java.nio.LongBuffer}   */
  public int glXGetVideoInfoNV(long dpy, int screen, int VideoDevice, LongBuffer pulCounterOutputPbuffer, LongBuffer pulCounterOutputVideo)  {

    if (!Buffers.isDirect(pulCounterOutputPbuffer))
      throw new GLException("Argument \"pulCounterOutputPbuffer\" is not a direct buffer");
    if (!Buffers.isDirect(pulCounterOutputVideo))
      throw new GLException("Argument \"pulCounterOutputVideo\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoInfoNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetVideoInfoNV"));
    }
        return dispatch_glXGetVideoInfoNV0(dpy, screen, VideoDevice, pulCounterOutputPbuffer, Buffers.getDirectBufferByteOffset(pulCounterOutputPbuffer), pulCounterOutputVideo, Buffers.getDirectBufferByteOffset(pulCounterOutputVideo), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoInfoNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo); </code> <br>Part of <code>GLX_NV_video_output</code>
      @param pulCounterOutputPbuffer a direct only {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct only {@link java.nio.LongBuffer}   */
  private native int dispatch_glXGetVideoInfoNV0(long dpy, int screen, int VideoDevice, Object pulCounterOutputPbuffer, int pulCounterOutputPbuffer_byte_offset, Object pulCounterOutputVideo, int pulCounterOutputVideo_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoSyncSGI(unsigned int *  count); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public int glXGetVideoSyncSGI(IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXGetVideoSyncSGI"));
    }
        return dispatch_glXGetVideoSyncSGI0(count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoSyncSGI(unsigned int *  count); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetVideoSyncSGI0(Object count, int count_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXImportContextEXT(Display *  dpy, XID contextID); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public long glXImportContextEXT(long dpy, long contextID)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXImportContextEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXImportContextEXT"));
    }
        return dispatch_glXImportContextEXT0(dpy, contextID, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXImportContextEXT(Display *  dpy, XID contextID); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  private native long dispatch_glXImportContextEXT0(long dpy, long contextID, long procAddress);

  /** Entry point to C language function: <code> Bool glXJoinSwapGroupNV(Display *  dpy, XID drawable, GLuint group); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXJoinSwapGroupNV(long dpy, long drawable, int group)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXJoinSwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXJoinSwapGroupNV"));
    }
        return dispatch_glXJoinSwapGroupNV0(dpy, drawable, group, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXJoinSwapGroupNV(Display *  dpy, XID drawable, GLuint group); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  private native boolean dispatch_glXJoinSwapGroupNV0(long dpy, long drawable, int group, long procAddress);

  /** Entry point to C language function: <code> void glXJoinSwapGroupSGIX(Display *  dpy, XID drawable, XID member); </code> <br>Part of <code>GLX_SGIX_swap_group</code>   */
  public void glXJoinSwapGroupSGIX(long dpy, long drawable, long member)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXJoinSwapGroupSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXJoinSwapGroupSGIX"));
    }
        dispatch_glXJoinSwapGroupSGIX0(dpy, drawable, member, __addr_);
  }

  /** Entry point to C language function: <code> void glXJoinSwapGroupSGIX(Display *  dpy, XID drawable, XID member); </code> <br>Part of <code>GLX_SGIX_swap_group</code>   */
  private native void dispatch_glXJoinSwapGroupSGIX0(long dpy, long drawable, long member, long procAddress);

  /** Entry point to C language function: <code> void glXLockVideoCaptureDeviceNV(Display *  dpy, XID device); </code> <br>Part of <code>GLX_NV_video_capture</code>   */
  public void glXLockVideoCaptureDeviceNV(long dpy, long device)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXLockVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXLockVideoCaptureDeviceNV"));
    }
        dispatch_glXLockVideoCaptureDeviceNV0(dpy, device, __addr_);
  }

  /** Entry point to C language function: <code> void glXLockVideoCaptureDeviceNV(Display *  dpy, XID device); </code> <br>Part of <code>GLX_NV_video_capture</code>   */
  private native void dispatch_glXLockVideoCaptureDeviceNV0(long dpy, long device, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeCurrentReadSGI(Display *  dpy, XID draw, XID read, GLXContext ctx); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public boolean glXMakeCurrentReadSGI(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXMakeCurrentReadSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXMakeCurrentReadSGI"));
    }
        return dispatch_glXMakeCurrentReadSGI0(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeCurrentReadSGI(Display *  dpy, XID draw, XID read, GLXContext ctx); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  private native boolean dispatch_glXMakeCurrentReadSGI0(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> int glXQueryChannelDeltasSGIX(Display *  display, int screen, int channel, int *  x, int *  y, int *  w, int *  h); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param x a direct only {@link java.nio.IntBuffer}
      @param y a direct only {@link java.nio.IntBuffer}
      @param w a direct only {@link java.nio.IntBuffer}
      @param h a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryChannelDeltasSGIX(long display, int screen, int channel, IntBuffer x, IntBuffer y, IntBuffer w, IntBuffer h)  {

    if (!Buffers.isDirect(x))
      throw new GLException("Argument \"x\" is not a direct buffer");
    if (!Buffers.isDirect(y))
      throw new GLException("Argument \"y\" is not a direct buffer");
    if (!Buffers.isDirect(w))
      throw new GLException("Argument \"w\" is not a direct buffer");
    if (!Buffers.isDirect(h))
      throw new GLException("Argument \"h\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelDeltasSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryChannelDeltasSGIX"));
    }
        return dispatch_glXQueryChannelDeltasSGIX0(display, screen, channel, x, Buffers.getDirectBufferByteOffset(x), y, Buffers.getDirectBufferByteOffset(y), w, Buffers.getDirectBufferByteOffset(w), h, Buffers.getDirectBufferByteOffset(h), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryChannelDeltasSGIX(Display *  display, int screen, int channel, int *  x, int *  y, int *  w, int *  h); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param x a direct only {@link java.nio.IntBuffer}
      @param y a direct only {@link java.nio.IntBuffer}
      @param w a direct only {@link java.nio.IntBuffer}
      @param h a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryChannelDeltasSGIX0(long display, int screen, int channel, Object x, int x_byte_offset, Object y, int y_byte_offset, Object w, int w_byte_offset, Object h, int h_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXQueryChannelRectSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param dx a direct only {@link java.nio.IntBuffer}
      @param dy a direct only {@link java.nio.IntBuffer}
      @param dw a direct only {@link java.nio.IntBuffer}
      @param dh a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryChannelRectSGIX(long display, int screen, int channel, IntBuffer dx, IntBuffer dy, IntBuffer dw, IntBuffer dh)  {

    if (!Buffers.isDirect(dx))
      throw new GLException("Argument \"dx\" is not a direct buffer");
    if (!Buffers.isDirect(dy))
      throw new GLException("Argument \"dy\" is not a direct buffer");
    if (!Buffers.isDirect(dw))
      throw new GLException("Argument \"dw\" is not a direct buffer");
    if (!Buffers.isDirect(dh))
      throw new GLException("Argument \"dh\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelRectSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryChannelRectSGIX"));
    }
        return dispatch_glXQueryChannelRectSGIX0(display, screen, channel, dx, Buffers.getDirectBufferByteOffset(dx), dy, Buffers.getDirectBufferByteOffset(dy), dw, Buffers.getDirectBufferByteOffset(dw), dh, Buffers.getDirectBufferByteOffset(dh), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryChannelRectSGIX(Display *  display, int screen, int channel, int *  dx, int *  dy, int *  dw, int *  dh); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param dx a direct only {@link java.nio.IntBuffer}
      @param dy a direct only {@link java.nio.IntBuffer}
      @param dw a direct only {@link java.nio.IntBuffer}
      @param dh a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryChannelRectSGIX0(long display, int screen, int channel, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object dw, int dw_byte_offset, Object dh, int dh_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXQueryContextInfoEXT(Display *  dpy, GLXContext context, int attribute, int *  value); </code> <br>Part of <code>GLX_EXT_import_context</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryContextInfoEXT(long dpy, long context, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryContextInfoEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryContextInfoEXT"));
    }
        return dispatch_glXQueryContextInfoEXT0(dpy, context, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryContextInfoEXT(Display *  dpy, GLXContext context, int attribute, int *  value); </code> <br>Part of <code>GLX_EXT_import_context</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryContextInfoEXT0(long dpy, long context, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryFrameCountNV(Display *  dpy, int screen, GLuint *  count); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryFrameCountNV(long dpy, int screen, IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryFrameCountNV"));
    }
        return dispatch_glXQueryFrameCountNV0(dpy, screen, count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryFrameCountNV(Display *  dpy, int screen, GLuint *  count); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryFrameCountNV0(long dpy, int screen, Object count, int count_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapBarriersSGIX(Display *  dpy, int screen, int *  max); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>
      @param max a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryMaxSwapBarriersSGIX(long dpy, int screen, IntBuffer max)  {

    if (!Buffers.isDirect(max))
      throw new GLException("Argument \"max\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapBarriersSGIX;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryMaxSwapBarriersSGIX"));
    }
        return dispatch_glXQueryMaxSwapBarriersSGIX0(dpy, screen, max, Buffers.getDirectBufferByteOffset(max), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapBarriersSGIX(Display *  dpy, int screen, int *  max); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>
      @param max a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryMaxSwapBarriersSGIX0(long dpy, int screen, Object max, int max_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapGroupsNV(Display *  dpy, int screen, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryMaxSwapGroupsNV(long dpy, int screen, IntBuffer maxGroups, IntBuffer maxBarriers)  {

    if (!Buffers.isDirect(maxGroups))
      throw new GLException("Argument \"maxGroups\" is not a direct buffer");
    if (!Buffers.isDirect(maxBarriers))
      throw new GLException("Argument \"maxBarriers\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryMaxSwapGroupsNV"));
    }
        return dispatch_glXQueryMaxSwapGroupsNV0(dpy, screen, maxGroups, Buffers.getDirectBufferByteOffset(maxGroups), maxBarriers, Buffers.getDirectBufferByteOffset(maxBarriers), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapGroupsNV(Display *  dpy, int screen, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryMaxSwapGroupsNV0(long dpy, int screen, Object maxGroups, int maxGroups_byte_offset, Object maxBarriers, int maxBarriers_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQuerySwapGroupNV(Display *  dpy, XID drawable, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQuerySwapGroupNV(long dpy, long drawable, IntBuffer group, IntBuffer barrier)  {

    if (!Buffers.isDirect(group))
      throw new GLException("Argument \"group\" is not a direct buffer");
    if (!Buffers.isDirect(barrier))
      throw new GLException("Argument \"barrier\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQuerySwapGroupNV"));
    }
        return dispatch_glXQuerySwapGroupNV0(dpy, drawable, group, Buffers.getDirectBufferByteOffset(group), barrier, Buffers.getDirectBufferByteOffset(barrier), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQuerySwapGroupNV(Display *  dpy, XID drawable, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQuerySwapGroupNV0(long dpy, long drawable, Object group, int group_byte_offset, Object barrier, int barrier_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXQueryVideoCaptureDeviceNV(Display *  dpy, XID device, int attribute, int *  value); </code> <br>Part of <code>GLX_NV_video_capture</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryVideoCaptureDeviceNV(long dpy, long device, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXQueryVideoCaptureDeviceNV"));
    }
        return dispatch_glXQueryVideoCaptureDeviceNV0(dpy, device, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryVideoCaptureDeviceNV(Display *  dpy, XID device, int attribute, int *  value); </code> <br>Part of <code>GLX_NV_video_capture</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryVideoCaptureDeviceNV0(long dpy, long device, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXReleaseBuffersMESA(Display *  dpy, XID drawable); </code> <br>Part of <code>GLX_MESA_release_buffers</code>   */
  public boolean glXReleaseBuffersMESA(long dpy, long drawable)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseBuffersMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseBuffersMESA"));
    }
        return dispatch_glXReleaseBuffersMESA0(dpy, drawable, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXReleaseBuffersMESA(Display *  dpy, XID drawable); </code> <br>Part of <code>GLX_MESA_release_buffers</code>   */
  private native boolean dispatch_glXReleaseBuffersMESA0(long dpy, long drawable, long procAddress);

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public void glXReleaseTexImageEXT(long dpy, long drawable, int buffer)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseTexImageEXT"));
    }
        dispatch_glXReleaseTexImageEXT0(dpy, drawable, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  private native void dispatch_glXReleaseTexImageEXT0(long dpy, long drawable, int buffer, long procAddress);

  /** Entry point to C language function: <code> void glXReleaseVideoCaptureDeviceNV(Display *  dpy, XID device); </code> <br>Part of <code>GLX_NV_video_capture</code>   */
  public void glXReleaseVideoCaptureDeviceNV(long dpy, long device)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoCaptureDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseVideoCaptureDeviceNV"));
    }
        dispatch_glXReleaseVideoCaptureDeviceNV0(dpy, device, __addr_);
  }

  /** Entry point to C language function: <code> void glXReleaseVideoCaptureDeviceNV(Display *  dpy, XID device); </code> <br>Part of <code>GLX_NV_video_capture</code>   */
  private native void dispatch_glXReleaseVideoCaptureDeviceNV0(long dpy, long device, long procAddress);

  /** Entry point to C language function: <code> int glXReleaseVideoDeviceNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice); </code> <br>Part of <code>GLX_NV_video_output</code>   */
  public int glXReleaseVideoDeviceNV(long dpy, int screen, int VideoDevice)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseVideoDeviceNV"));
    }
        return dispatch_glXReleaseVideoDeviceNV0(dpy, screen, VideoDevice, __addr_);
  }

  /** Entry point to C language function: <code> int glXReleaseVideoDeviceNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice); </code> <br>Part of <code>GLX_NV_video_output</code>   */
  private native int dispatch_glXReleaseVideoDeviceNV0(long dpy, int screen, int VideoDevice, long procAddress);

  /** Entry point to C language function: <code> int glXReleaseVideoImageNV(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_NV_video_output</code>   */
  public int glXReleaseVideoImageNV(long dpy, long pbuf)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXReleaseVideoImageNV"));
    }
        return dispatch_glXReleaseVideoImageNV0(dpy, pbuf, __addr_);
  }

  /** Entry point to C language function: <code> int glXReleaseVideoImageNV(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_NV_video_output</code>   */
  private native int dispatch_glXReleaseVideoImageNV0(long dpy, long pbuf, long procAddress);

  /** Entry point to C language function: <code> Bool glXResetFrameCountNV(Display *  dpy, int screen); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXResetFrameCountNV(long dpy, int screen)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXResetFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXResetFrameCountNV"));
    }
        return dispatch_glXResetFrameCountNV0(dpy, screen, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXResetFrameCountNV(Display *  dpy, int screen); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  private native boolean dispatch_glXResetFrameCountNV0(long dpy, int screen, long procAddress);

  /** Entry point to C language function: <code> int glXSendPbufferToVideoNV(Display *  dpy, XID pbuf, int iBufferType, unsigned long *  pulCounterPbuffer, GLboolean bBlock); </code> <br>Part of <code>GLX_NV_video_output</code>
      @param pulCounterPbuffer a direct only {@link java.nio.LongBuffer}   */
  public int glXSendPbufferToVideoNV(long dpy, long pbuf, int iBufferType, LongBuffer pulCounterPbuffer, boolean bBlock)  {

    if (!Buffers.isDirect(pulCounterPbuffer))
      throw new GLException("Argument \"pulCounterPbuffer\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSendPbufferToVideoNV;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSendPbufferToVideoNV"));
    }
        return dispatch_glXSendPbufferToVideoNV0(dpy, pbuf, iBufferType, pulCounterPbuffer, Buffers.getDirectBufferByteOffset(pulCounterPbuffer), bBlock, __addr_);
  }

  /** Entry point to C language function: <code> int glXSendPbufferToVideoNV(Display *  dpy, XID pbuf, int iBufferType, unsigned long *  pulCounterPbuffer, GLboolean bBlock); </code> <br>Part of <code>GLX_NV_video_output</code>
      @param pulCounterPbuffer a direct only {@link java.nio.LongBuffer}   */
  private native int dispatch_glXSendPbufferToVideoNV0(long dpy, long pbuf, int iBufferType, Object pulCounterPbuffer, int pulCounterPbuffer_byte_offset, boolean bBlock, long procAddress);

  /** Entry point to C language function: <code> Bool glXSet3DfxModeMESA(int mode); </code> <br>Part of <code>GLX_MESA_set_3dfx_mode</code>   */
  public boolean glXSet3DfxModeMESA(int mode)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSet3DfxModeMESA;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSet3DfxModeMESA"));
    }
        return dispatch_glXSet3DfxModeMESA0(mode, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXSet3DfxModeMESA(int mode); </code> <br>Part of <code>GLX_MESA_set_3dfx_mode</code>   */
  private native boolean dispatch_glXSet3DfxModeMESA0(int mode, long procAddress);

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public long glXSwapBuffersMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapBuffersMscOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSwapBuffersMscOML"));
    }
        return dispatch_glXSwapBuffersMscOML0(dpy, drawable, target_msc, divisor, remainder, __addr_);
  }

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  private native long dispatch_glXSwapBuffersMscOML0(long dpy, long drawable, long target_msc, long divisor, long remainder, long procAddress);

  /** Entry point to C language function: <code> void glXSwapIntervalEXT(Display *  dpy, XID drawable, int interval); </code> <br>Part of <code>GLX_EXT_swap_control</code>   */
  public void glXSwapIntervalEXT(long dpy, long drawable, int interval)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSwapIntervalEXT"));
    }
        dispatch_glXSwapIntervalEXT0(dpy, drawable, interval, __addr_);
  }

  /** Entry point to C language function: <code> void glXSwapIntervalEXT(Display *  dpy, XID drawable, int interval); </code> <br>Part of <code>GLX_EXT_swap_control</code>   */
  private native void dispatch_glXSwapIntervalEXT0(long dpy, long drawable, int interval, long procAddress);

  /** Entry point to C language function: <code> int glXSwapIntervalSGI(int interval); </code> <br>Part of <code>GLX_SGI_swap_control</code>   */
  public int glXSwapIntervalSGI(int interval)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapIntervalSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXSwapIntervalSGI"));
    }
        return dispatch_glXSwapIntervalSGI0(interval, __addr_);
  }

  /** Entry point to C language function: <code> int glXSwapIntervalSGI(int interval); </code> <br>Part of <code>GLX_SGI_swap_control</code>   */
  private native int dispatch_glXSwapIntervalSGI0(int interval, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  public boolean glXWaitForMscOML(long dpy, long drawable, long target_msc, long divisor, long remainder, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    if (!Buffers.isDirect(ust))
      throw new GLException("Argument \"ust\" is not a direct buffer");
    if (!Buffers.isDirect(msc))
      throw new GLException("Argument \"msc\" is not a direct buffer");
    if (!Buffers.isDirect(sbc))
      throw new GLException("Argument \"sbc\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForMscOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXWaitForMscOML"));
    }
        return dispatch_glXWaitForMscOML0(dpy, drawable, target_msc, divisor, remainder, ust, Buffers.getDirectBufferByteOffset(ust), msc, Buffers.getDirectBufferByteOffset(msc), sbc, Buffers.getDirectBufferByteOffset(sbc), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display *  dpy, XID drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXWaitForMscOML0(long dpy, long drawable, long target_msc, long divisor, long remainder, Object ust, int ust_byte_offset, Object msc, int msc_byte_offset, Object sbc, int sbc_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, XID drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  public boolean glXWaitForSbcOML(long dpy, long drawable, long target_sbc, LongBuffer ust, LongBuffer msc, LongBuffer sbc)  {

    if (!Buffers.isDirect(ust))
      throw new GLException("Argument \"ust\" is not a direct buffer");
    if (!Buffers.isDirect(msc))
      throw new GLException("Argument \"msc\" is not a direct buffer");
    if (!Buffers.isDirect(sbc))
      throw new GLException("Argument \"sbc\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForSbcOML;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXWaitForSbcOML"));
    }
        return dispatch_glXWaitForSbcOML0(dpy, drawable, target_sbc, ust, Buffers.getDirectBufferByteOffset(ust), msc, Buffers.getDirectBufferByteOffset(msc), sbc, Buffers.getDirectBufferByteOffset(sbc), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display *  dpy, XID drawable, int64_t target_sbc, int64_t *  ust, int64_t *  msc, int64_t *  sbc); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param ust a direct only {@link java.nio.LongBuffer}
      @param msc a direct only {@link java.nio.LongBuffer}
      @param sbc a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXWaitForSbcOML0(long dpy, long drawable, long target_sbc, Object ust, int ust_byte_offset, Object msc, int msc_byte_offset, Object sbc, int sbc_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *  count); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public int glXWaitVideoSyncSGI(int divisor, int remainder, IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException(String.format("Method \"%s\" not available", "glXWaitVideoSyncSGI"));
    }
        return dispatch_glXWaitVideoSyncSGI0(divisor, remainder, count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *  count); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXWaitVideoSyncSGI0(int divisor, int remainder, Object count, int count_byte_offset, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public GLXExtImpl(X11GLXContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private X11GLXContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLXExtImpl
