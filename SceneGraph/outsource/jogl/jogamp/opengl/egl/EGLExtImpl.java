/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Tue Mar 11 04:18:52 CET 2014 ----! */

package jogamp.opengl.egl;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class EGLExtImpl implements EGLExt{
  /** Entry point to C language function: <code> EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public int eglClientWaitSyncKHR(long dpy, long sync, int flags, long timeout)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglClientWaitSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglClientWaitSyncKHR"));
    }
        return dispatch_eglClientWaitSyncKHR0(dpy, sync, flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  private native int dispatch_eglClientWaitSyncKHR0(long dpy, long sync, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncNV(EGLClientBuffer sync, EGLint flags, EGLTimeNV timeout); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  public int eglClientWaitSyncNV(Buffer sync, int flags, long timeout)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglClientWaitSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglClientWaitSyncNV"));
    }
        return dispatch_eglClientWaitSyncNV0(sync, Buffers.getDirectBufferByteOffset(sync), flags, timeout, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglClientWaitSyncNV(EGLClientBuffer sync, EGLint flags, EGLTimeNV timeout); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native int dispatch_eglClientWaitSyncNV0(Object sync, int sync_byte_offset, int flags, long timeout, long procAddress);

  /** Entry point to C language function: <code> EGLImageKHR eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_MESA_drm_image</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateDRMImageMESA(long dpy, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateDRMImageMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateDRMImageMESA"));
    }
        return dispatch_eglCreateDRMImageMESA0(dpy, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLImageKHR eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_MESA_drm_image</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateDRMImageMESA0(long dpy, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLClientBuffer eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_NV_sync</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public ByteBuffer eglCreateFenceSyncNV(long dpy, int condition, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateFenceSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateFenceSyncNV"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateFenceSyncNV0(dpy, condition, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLClientBuffer eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_NV_sync</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_eglCreateFenceSyncNV0(long dpy, int condition, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_image</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateImageKHR(long dpy, long ctx, int target, Buffer buffer, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(buffer))
      throw new RuntimeException("Argument \"buffer\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateImageKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateImageKHR"));
    }
        return dispatch_eglCreateImageKHR0(dpy, ctx, target, buffer, Buffers.getDirectBufferByteOffset(buffer), attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_image</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateImageKHR0(long dpy, long ctx, int target, Object buffer, int buffer_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, EGLClientPixmapHI *  pixmap); </code> <br>Part of <code>EGL_HI_clientpixmap</code>   */
  public long eglCreatePixmapSurfaceHI(long dpy, long config, EGLClientPixmapHI pixmap)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreatePixmapSurfaceHI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreatePixmapSurfaceHI"));
    }
        return dispatch_eglCreatePixmapSurfaceHI0(dpy, config, ((pixmap == null) ? null : pixmap.getBuffer()), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, EGLClientPixmapHI *  pixmap); </code> <br>Part of <code>EGL_HI_clientpixmap</code>   */
  private native long dispatch_eglCreatePixmapSurfaceHI0(long dpy, long config, ByteBuffer pixmap, long procAddress);

  /** Entry point to C language function: <code> EGLClientBuffer eglCreateStreamFromFileDescriptorKHR(EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor); </code> <br>Part of <code>EGL_KHR_stream_cross_process_fd</code>   */
  public ByteBuffer eglCreateStreamFromFileDescriptorKHR(long dpy, int file_descriptor)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateStreamFromFileDescriptorKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateStreamFromFileDescriptorKHR"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateStreamFromFileDescriptorKHR0(dpy, file_descriptor, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLClientBuffer eglCreateStreamFromFileDescriptorKHR(EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor); </code> <br>Part of <code>EGL_KHR_stream_cross_process_fd</code>   */
  private native ByteBuffer dispatch_eglCreateStreamFromFileDescriptorKHR0(long dpy, int file_descriptor, long procAddress);

  /** Entry point to C language function: <code> EGLClientBuffer eglCreateStreamKHR(EGLDisplay dpy, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public ByteBuffer eglCreateStreamKHR(long dpy, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateStreamKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateStreamKHR"));
    }
    final ByteBuffer _res;
    _res = dispatch_eglCreateStreamKHR0(dpy, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> EGLClientBuffer eglCreateStreamKHR(EGLDisplay dpy, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_eglCreateStreamKHR0(long dpy, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config, EGLClientBuffer stream, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_stream_producer_eglsurface</code>
      @param stream a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateStreamProducerSurfaceKHR(long dpy, long config, Buffer stream, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateStreamProducerSurfaceKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateStreamProducerSurfaceKHR"));
    }
        return dispatch_eglCreateStreamProducerSurfaceKHR0(dpy, config, stream, Buffers.getDirectBufferByteOffset(stream), attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config, EGLClientBuffer stream, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_stream_producer_eglsurface</code>
      @param stream a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateStreamProducerSurfaceKHR0(long dpy, long config, Object stream, int stream_byte_offset, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public long eglCreateSyncKHR(long dpy, int type, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglCreateSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglCreateSyncKHR"));
    }
        return dispatch_eglCreateSyncKHR0(dpy, type, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_eglCreateSyncKHR0(long dpy, int type, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image); </code> <br>Part of <code>EGL_KHR_image</code>   */
  public boolean eglDestroyImageKHR(long dpy, long image)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDestroyImageKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroyImageKHR"));
    }
        return dispatch_eglDestroyImageKHR0(dpy, image, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image); </code> <br>Part of <code>EGL_KHR_image</code>   */
  private native boolean dispatch_eglDestroyImageKHR0(long dpy, long image, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglDestroyStreamKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDestroyStreamKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroyStreamKHR"));
    }
        return dispatch_eglDestroyStreamKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglDestroyStreamKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public boolean eglDestroySyncKHR(long dpy, long sync)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDestroySyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroySyncKHR"));
    }
        return dispatch_eglDestroySyncKHR0(dpy, sync, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  private native boolean dispatch_eglDestroySyncKHR0(long dpy, long sync, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncNV(EGLClientBuffer sync); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  public boolean eglDestroySyncNV(Buffer sync)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDestroySyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDestroySyncNV"));
    }
        return dispatch_eglDestroySyncNV0(sync, Buffers.getDirectBufferByteOffset(sync), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySyncNV(EGLClientBuffer sync); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglDestroySyncNV0(Object sync, int sync_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR); </code> <br>Part of <code>EGL_ANDROID_native_fence_sync</code>   */
  public int eglDupNativeFenceFDANDROID(long dpy, long arg1)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglDupNativeFenceFDANDROID;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglDupNativeFenceFDANDROID"));
    }
        return dispatch_eglDupNativeFenceFDANDROID0(dpy, arg1, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR); </code> <br>Part of <code>EGL_ANDROID_native_fence_sync</code>   */
  private native int dispatch_eglDupNativeFenceFDANDROID0(long dpy, long arg1, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *  name, EGLint *  handle, EGLint *  stride); </code> <br>Part of <code>EGL_MESA_drm_image</code>
      @param name a direct only {@link java.nio.IntBuffer}
      @param handle a direct only {@link java.nio.IntBuffer}
      @param stride a direct only {@link java.nio.IntBuffer}   */
  public boolean eglExportDRMImageMESA(long dpy, long image, IntBuffer name, IntBuffer handle, IntBuffer stride)  {

    if (!Buffers.isDirect(name))
      throw new RuntimeException("Argument \"name\" is not a direct buffer");
    if (!Buffers.isDirect(handle))
      throw new RuntimeException("Argument \"handle\" is not a direct buffer");
    if (!Buffers.isDirect(stride))
      throw new RuntimeException("Argument \"stride\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglExportDRMImageMESA;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglExportDRMImageMESA"));
    }
        return dispatch_eglExportDRMImageMESA0(dpy, image, name, Buffers.getDirectBufferByteOffset(name), handle, Buffers.getDirectBufferByteOffset(handle), stride, Buffers.getDirectBufferByteOffset(stride), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *  name, EGLint *  handle, EGLint *  stride); </code> <br>Part of <code>EGL_MESA_drm_image</code>
      @param name a direct only {@link java.nio.IntBuffer}
      @param handle a direct only {@link java.nio.IntBuffer}
      @param stride a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglExportDRMImageMESA0(long dpy, long image, Object name, int name_byte_offset, Object handle, int handle_byte_offset, Object stride, int stride_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglFenceNV(EGLClientBuffer sync); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  public boolean eglFenceNV(Buffer sync)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglFenceNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglFenceNV"));
    }
        return dispatch_eglFenceNV0(sync, Buffers.getDirectBufferByteOffset(sync), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglFenceNV(EGLClientBuffer sync); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglFenceNV0(Object sync, int sync_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream_cross_process_fd</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  public int eglGetStreamFileDescriptorKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetStreamFileDescriptorKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetStreamFileDescriptorKHR"));
    }
        return dispatch_eglGetStreamFileDescriptorKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream_cross_process_fd</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native int dispatch_eglGetStreamFileDescriptorKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean eglGetSyncAttribKHR(long dpy, long sync, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSyncAttribKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSyncAttribKHR"));
    }
        return dispatch_eglGetSyncAttribKHR0(dpy, sync, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetSyncAttribKHR0(long dpy, long sync, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribNV(EGLClientBuffer sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean eglGetSyncAttribNV(Buffer sync, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSyncAttribNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSyncAttribNV"));
    }
        return dispatch_eglGetSyncAttribNV0(sync, Buffers.getDirectBufferByteOffset(sync), attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetSyncAttribNV(EGLClientBuffer sync, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglGetSyncAttribNV0(Object sync, int sync_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLuint64 eglGetSystemTimeFrequencyNV(void); </code> <br>Part of <code>EGL_NV_system_time</code>   */
  public long eglGetSystemTimeFrequencyNV()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSystemTimeFrequencyNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSystemTimeFrequencyNV"));
    }
        return dispatch_eglGetSystemTimeFrequencyNV0(__addr_);
  }

  /** Entry point to C language function: <code> EGLuint64 eglGetSystemTimeFrequencyNV(void); </code> <br>Part of <code>EGL_NV_system_time</code>   */
  private native long dispatch_eglGetSystemTimeFrequencyNV0(long procAddress);

  /** Entry point to C language function: <code> EGLuint64 eglGetSystemTimeNV(void); </code> <br>Part of <code>EGL_NV_system_time</code>   */
  public long eglGetSystemTimeNV()  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglGetSystemTimeNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglGetSystemTimeNV"));
    }
        return dispatch_eglGetSystemTimeNV0(__addr_);
  }

  /** Entry point to C language function: <code> EGLuint64 eglGetSystemTimeNV(void); </code> <br>Part of <code>EGL_NV_system_time</code>   */
  private native long dispatch_eglGetSystemTimeNV0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_lock_surface</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public boolean eglLockSurfaceKHR(long display, long surface, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglLockSurfaceKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglLockSurfaceKHR"));
    }
        return dispatch_eglLockSurfaceKHR0(display, surface, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_KHR_lock_surface</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglLockSurfaceKHR0(long display, long surface, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height); </code> <br>Part of <code>EGL_NV_post_sub_buffer</code>   */
  public boolean eglPostSubBufferNV(long dpy, long surface, int x, int y, int width, int height)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglPostSubBufferNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglPostSubBufferNV"));
    }
        return dispatch_eglPostSubBufferNV0(dpy, surface, x, y, width, height, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height); </code> <br>Part of <code>EGL_NV_post_sub_buffer</code>   */
  private native boolean dispatch_eglPostSubBufferNV0(long dpy, long surface, int x, int y, int width, int height, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativeDisplayNV(EGLDisplay dpy, EGLNativeDisplayType *  display_id); </code> <br>Part of <code>EGL_NV_native_query</code>
      @param display_id a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryNativeDisplayNV(long dpy, PointerBuffer display_id)  {

    if (!Buffers.isDirect(display_id))
      throw new RuntimeException("Argument \"display_id\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryNativeDisplayNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryNativeDisplayNV"));
    }
        return dispatch_eglQueryNativeDisplayNV0(dpy, display_id != null ? display_id.getBuffer() : null, Buffers.getDirectBufferByteOffset(display_id), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativeDisplayNV(EGLDisplay dpy, EGLNativeDisplayType *  display_id); </code> <br>Part of <code>EGL_NV_native_query</code>
      @param display_id a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryNativeDisplayNV0(long dpy, Object display_id, int display_id_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativePixmapNV(EGLDisplay dpy, EGLSurface surf, EGLNativePixmapType *  pixmap); </code> <br>Part of <code>EGL_NV_native_query</code>
      @param pixmap a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryNativePixmapNV(long dpy, long surf, PointerBuffer pixmap)  {

    if (!Buffers.isDirect(pixmap))
      throw new RuntimeException("Argument \"pixmap\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryNativePixmapNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryNativePixmapNV"));
    }
        return dispatch_eglQueryNativePixmapNV0(dpy, surf, pixmap != null ? pixmap.getBuffer() : null, Buffers.getDirectBufferByteOffset(pixmap), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativePixmapNV(EGLDisplay dpy, EGLSurface surf, EGLNativePixmapType *  pixmap); </code> <br>Part of <code>EGL_NV_native_query</code>
      @param pixmap a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryNativePixmapNV0(long dpy, long surf, Object pixmap, int pixmap_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativeWindowNV(EGLDisplay dpy, EGLSurface surf, EGLNativeWindowType *  window); </code> <br>Part of <code>EGL_NV_native_query</code>
      @param window a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQueryNativeWindowNV(long dpy, long surf, PointerBuffer window)  {

    if (!Buffers.isDirect(window))
      throw new RuntimeException("Argument \"window\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryNativeWindowNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryNativeWindowNV"));
    }
        return dispatch_eglQueryNativeWindowNV0(dpy, surf, window != null ? window.getBuffer() : null, Buffers.getDirectBufferByteOffset(window), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryNativeWindowNV(EGLDisplay dpy, EGLSurface surf, EGLNativeWindowType *  window); </code> <br>Part of <code>EGL_NV_native_query</code>
      @param window a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQueryNativeWindowNV0(long dpy, long surf, Object window, int window_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLClientBuffer stream, EGLenum attribute, EGLint *  value); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.IntBuffer}   */
  public boolean eglQueryStreamKHR(long dpy, Buffer stream, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryStreamKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryStreamKHR"));
    }
        return dispatch_eglQueryStreamKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLClientBuffer stream, EGLenum attribute, EGLint *  value); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglQueryStreamKHR0(long dpy, Object stream, int stream_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLClientBuffer stream, EGLenum attribute, EGLTimeKHR *  value); </code> <br>Part of <code>EGL_KHR_stream_fifo</code>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.LongBuffer}   */
  public boolean eglQueryStreamTimeKHR(long dpy, Buffer stream, int attribute, LongBuffer value)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryStreamTimeKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryStreamTimeKHR"));
    }
        return dispatch_eglQueryStreamTimeKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLClientBuffer stream, EGLenum attribute, EGLTimeKHR *  value); </code> <br>Part of <code>EGL_KHR_stream_fifo</code>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_eglQueryStreamTimeKHR0(long dpy, Object stream, int stream_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLClientBuffer stream, EGLenum attribute, EGLuint64KHR *  value); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.LongBuffer}   */
  public boolean eglQueryStreamu64KHR(long dpy, Buffer stream, int attribute, LongBuffer value)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQueryStreamu64KHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQueryStreamu64KHR"));
    }
        return dispatch_eglQueryStreamu64KHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLClientBuffer stream, EGLenum attribute, EGLuint64KHR *  value); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param stream a direct only {@link java.nio.Buffer}
      @param value a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_eglQueryStreamu64KHR0(long dpy, Object stream, int stream_byte_offset, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLClientBuffer *  value); </code> <br>Part of <code>EGL_ANGLE_query_surface_pointer</code>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  public boolean eglQuerySurfacePointerANGLE(long dpy, long surface, int attribute, PointerBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglQuerySurfacePointerANGLE;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglQuerySurfacePointerANGLE"));
    }
        return dispatch_eglQuerySurfacePointerANGLE0(dpy, surface, attribute, value != null ? value.getBuffer() : null, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLClientBuffer *  value); </code> <br>Part of <code>EGL_ANGLE_query_surface_pointer</code>
      @param value a direct only {@link com.jogamp.common.nio.PointerBuffer}   */
  private native boolean dispatch_eglQuerySurfacePointerANGLE0(long dpy, long surface, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  public boolean eglSignalSyncKHR(long dpy, long sync, int mode)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglSignalSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSignalSyncKHR"));
    }
        return dispatch_eglSignalSyncKHR0(dpy, sync, mode, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode); </code> <br>Part of <code>EGL_KHR_reusable_sync</code>   */
  private native boolean dispatch_eglSignalSyncKHR0(long dpy, long sync, int mode, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncNV(EGLClientBuffer sync, EGLenum mode); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  public boolean eglSignalSyncNV(Buffer sync, int mode)  {

    if (!Buffers.isDirect(sync))
      throw new RuntimeException("Argument \"sync\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglSignalSyncNV;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSignalSyncNV"));
    }
        return dispatch_eglSignalSyncNV0(sync, Buffers.getDirectBufferByteOffset(sync), mode, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSignalSyncNV(EGLClientBuffer sync, EGLenum mode); </code> <br>Part of <code>EGL_NV_sync</code>
      @param sync a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglSignalSyncNV0(Object sync, int sync_byte_offset, int mode, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLClientBuffer stream, EGLenum attribute, EGLint value); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglStreamAttribKHR(long dpy, Buffer stream, int attribute, int value)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglStreamAttribKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglStreamAttribKHR"));
    }
        return dispatch_eglStreamAttribKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), attribute, value, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLClientBuffer stream, EGLenum attribute, EGLint value); </code> <br>Part of <code>EGL_KHR_stream</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglStreamAttribKHR0(long dpy, Object stream, int stream_byte_offset, int attribute, int value, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglStreamConsumerAcquireKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglStreamConsumerAcquireKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglStreamConsumerAcquireKHR"));
    }
        return dispatch_eglStreamConsumerAcquireKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglStreamConsumerAcquireKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglStreamConsumerGLTextureExternalKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglStreamConsumerGLTextureExternalKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglStreamConsumerGLTextureExternalKHR"));
    }
        return dispatch_eglStreamConsumerGLTextureExternalKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglStreamConsumerGLTextureExternalKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  public boolean eglStreamConsumerReleaseKHR(long dpy, Buffer stream)  {

    if (!Buffers.isDirect(stream))
      throw new RuntimeException("Argument \"stream\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglStreamConsumerReleaseKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglStreamConsumerReleaseKHR"));
    }
        return dispatch_eglStreamConsumerReleaseKHR0(dpy, stream, Buffers.getDirectBufferByteOffset(stream), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy, EGLClientBuffer stream); </code> <br>Part of <code>EGL_KHR_stream_consumer_gltexture</code>
      @param stream a direct only {@link java.nio.Buffer}   */
  private native boolean dispatch_eglStreamConsumerReleaseKHR0(long dpy, Object stream, int stream_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersWithDamageEXT(EGLDisplay dpy, EGLSurface surface, EGLint *  rects, EGLint n_rects); </code> <br>Part of <code>EGL_EXT_swap_buffers_with_damage</code>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  public boolean eglSwapBuffersWithDamageEXT(long dpy, long surface, IntBuffer rects, int n_rects)  {

    if (!Buffers.isDirect(rects))
      throw new RuntimeException("Argument \"rects\" is not a direct buffer");
    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglSwapBuffersWithDamageEXT;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglSwapBuffersWithDamageEXT"));
    }
        return dispatch_eglSwapBuffersWithDamageEXT0(dpy, surface, rects, Buffers.getDirectBufferByteOffset(rects), n_rects, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffersWithDamageEXT(EGLDisplay dpy, EGLSurface surface, EGLint *  rects, EGLint n_rects); </code> <br>Part of <code>EGL_EXT_swap_buffers_with_damage</code>
      @param rects a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_eglSwapBuffersWithDamageEXT0(long dpy, long surface, Object rects, int rects_byte_offset, int n_rects, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface); </code> <br>Part of <code>EGL_KHR_lock_surface</code>   */
  public boolean eglUnlockSurfaceKHR(long display, long surface)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglUnlockSurfaceKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglUnlockSurfaceKHR"));
    }
        return dispatch_eglUnlockSurfaceKHR0(display, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface); </code> <br>Part of <code>EGL_KHR_lock_surface</code>   */
  private native boolean dispatch_eglUnlockSurfaceKHR0(long display, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags); </code> <br>Part of <code>EGL_KHR_wait_sync</code>   */
  public int eglWaitSyncKHR(long dpy, long sync, int flags)  {

    final long __addr_ = _context.getEGLExtProcAddressTable()._addressof_eglWaitSyncKHR;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException(String.format("Method \"%s\" not available", "eglWaitSyncKHR"));
    }
        return dispatch_eglWaitSyncKHR0(dpy, sync, flags, __addr_);
  }

  /** Entry point to C language function: <code> EGLint eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags); </code> <br>Part of <code>EGL_KHR_wait_sync</code>   */
  private native int dispatch_eglWaitSyncKHR0(long dpy, long sync, int flags, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public EGLExtImpl(EGLContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private EGLContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class EGLExtImpl
